{
    "url": "http://moyuyc.github.io/",
    "articles": [
        {
            "title": "数字验证码识别",
            "date": "2016-07-25",
            "content": " VerifyCodeJava 实现的数字验证码识别, …准确率不是很高, 模式识别和去噪处理的不是很好, 但学习入门已经够了， 而且！！！已经运用至之前做的教务系统的验证码识别整体的流程结构  识别思路首先，得到图片数据，如  然后我试着对图片进行各种处理，比如…  变成灰化图  去噪…好像效果不明显  对灰化图去噪  灰化图转成二值图（阈值128）  原图转成二值图（阈值128）  对二值图膨胀运算  对二值图腐蚀运算  对二值图开运算 (先腐蚀后膨胀)  对二值图闭运算 (先膨胀后腐蚀)   多次实验对比后，发现还是对原图的二值化图最好处理。 然后，便是将图片中的数字分割为固定大小的图片（固定大小是为了后续的模式学习与识别） 其实在这里我可以使用一种比较无赖的方式处理，将这种有规律的数字验证码按照像素点位置进行分割， 但是这样做就没意思了…，所以我选择了用深度优先搜索算法（利用堆栈结构，如果递归，会导致栈溢出）， 并且带标记（防止重复处理处理过的点），将八连通的集合分割出来   效果如下     当然二值图中的噪点会影响字符的划分 最后便是模式识别算法的选择了，我没有选中书上与网上说的基于向量距离的方法，而是自己想了一个方法，所以识别能力有限… 思路是：先将将一些已知数字的样本进行存储为一串字符串，白色存为”0”，黑色为”1” 效果如下  123456789101112131415160111111111011111111101111111111100000011100000001100000001100000000110000000110000010011000000001100000001100000000110000000011000000011000000001100000000110000  123456789101112131415160000000110000000011000000011100000011110000010111000010011100001001110001000111001000011101000001110111111111111111111110000001110000000111000000011100000001110 将图像编码完成后，对比待识别图片与10种数字样本之间字符”1”的位置吻合度，最高的即为识别出来的数字  但是这种方法容易将3，5，8识别错误，或者因为分割的不成功而导致的识别错误。 最后！提下Node调用Java的方法 目前我用的是child_process创建新进程，在新进程调用Java，传人图片文件地址进行处理。 但是！这种方法每次都需要重新启动Java，训练样本需要重新载入，效率是个问题。 2016/07/25更新!!! 改用 WebService 进行通信! 代码地址 Java源码 VerifyCode  一键查分（运用该技术） njnu-quick-get-score   参考资料形态学运算 http://blog.csdn.net/bagboy_taobao_com/article/details/5574159http://blog.csdn.net/hellousb2010/article/details/37939809 字符分割 https://www.zhihu.com/question/19702292http://www.voidcn.com/blog/beechina/article/p-5761020.html PDF 299 模式识别 ",
            "path": "/2016/07/25/数字验证码识别/"
        },
        {
            "title": "「滴滴滴，老司机开车了」nodejs爬取煎蛋网妹子图",
            "date": "2016-07-01",
            "content": " “流氓不可怕,就怕流氓有文化” 前天刚考完编译，今天考完网络，就开始捣鼓代码了，花了一天时间摸索了一下nodejs的爬虫，也就是tcp，http连接。  也是就做了一个爬取煎蛋网妹子图的爬虫，并保持至本地。 思路介绍 通过http请求报文模拟一次访问煎蛋网的操作 获取到了网页的HTML代码后，进行正则表达式匹配，得到图片地址 通过图片地址，再次发送http请求报文，将图片数据保存至本地思路简单了解后，便开始工作了。  然而并不是一帆风顺得不到HTML？参考资料http://chenxi.name/60.html，利用request包进行傻瓜式调用，然而并不能生效，将会跳转至一个屏蔽提示网页煎蛋网为了防止恶意爬取数据，进行了一定程度的防爬措施。但这可难不倒我，为什么在浏览器上就能正常浏览图片页面呢？于是我打开浏览器控制台，复制页面请求报文的cmd格式，粘贴至命令行中运行，能够正确得到HTML所以，我觉得问题就是出现在请求报文头部数据，于是复制下浏览器中报头，利用nodejs的http包，建立http连接。123456789require('http').get({ hostname:'jandan.net', path:'/', header:{ ... } },function(res){  }) 但是奇怪的是！还是响应302，跳转至屏蔽提示页面。 最后没办法的我只好利用底层一点的api——net包，建立tcp连接，发送符合http请求报文格式的数据。123456789101112131415161718192021222324252627var net = require('net');var header = require('fs').readFileSync('./header.txt').toString();module.exports = function (path,callback) { const socket = net.createConnection(80,'jandan.net'); socket.write( 'GET '+path+' HTTP/1.1\\r\\n'+ header ); socket.setEncoding('utf-8'); socket.setTimeout(4000,function () { callback(html); console.error(new Error('Time OUT')); socket.end(); }); var html = ''; socket.on('data',function (chunk) { html+=chunk; }); socket.on('end',function () { console.log('disconnected from server'); });} header.txt123456789Host: jandan.netConnection: keep-aliveCache-Control: max-age=0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36Referer: http://jandan.net/vAccept-Language: zh-CN,zh;q=0.8Cookie: gif-click-load=on; bad-click-load=on; PHPSESSID=u1gnmqnpb75injakbgvkb6r413; 4036050675=c119Yp%2BLrMWuv%2BWMyYtq3x6vTdbFzaTbUyoiLt%2Fv; jdna=596e6fb28c1bb47f949e65e1ae03f7f5#1467288596467; Hm_lvt_fd93b7fb546adcfbcf80c4fc2b54da2c=1467287791; Hm_lpvt_fd93b7fb546adcfbcf80c4fc2b54da2c=1467288598; _ga=GA1.2.330681373.1467287790 注意，header.txt最后需要两个\\r\\n表示请求报头结束最后果然是成功了，但具体两种方法的不同我也说不上来，希望有热心读者能告诉我。 数据传输同步异步？利用下面的递归方法加上Promise.all同步方法，防止过度的tcp连接（改用下面方法后，tcp读写错误明显减少，但还是会出现，不知道有没有大神帮我解决该问题呢？）1234567891011121314151617181920212223242526272829function run(i,low) { if(i<low) return; spider('/ooxx/page-'+i,function (html) { var images = []; html.replace(/<img.+?src=\"(http.+?sina.+?)\"/g,function (m,c) { images.unshift(c); }); var page = i; var proms = images.map((x,i,a)=>{ return new Promise((resolve,reject)=>{ var req = http.get(x,function (res) { res.on('error',function (err) { console.error(err); resolve('fail'); }); var filename = x.substr(x.lastIndexOf('/')+1); download(dir+'/'+filename,res); console.log('PAGE:'+page+'...'+filename+'...'+(i+1)+'/'+a.length); resolve('done'); }).end(); }); }); Promise.all(proms) .then((values)=>{ //上一页的图片加入下载队列后，再开始递归下一页。 run(i-1,low); }); });} 最后文件夹就像下面一样！ 甩下代码地址，飙个车jandan-spider 关注我的博客moyuyc.github.io ,有技术的老司机带你飙车！  ",
            "path": "/2016/07/01/「滴滴滴，老司机开车了」nodejs爬取煎蛋网妹子图/"
        },
        {
            "title": "图书销售系统（书窝）",
            "date": "2016-06-20",
            "content": " 图书销售系统 —— 书窝书窝线上地址GitHub地址由于时间有限，事务较重，系统实现只好从简。  需求分析 需交课程设计报告和软件（源代码）。课程设计报告将存档。报告内容包括：需求分析、算法思想描述、数据流图、E-R图、数据字典、程序结构、收获与体会等。功能要求：实现一个基于web的网上图书的销售管理系统，能提供多种条件的查询，还应具有会员管理、意见反馈、销售分析等功能。将留言板、图表分析、文件上传等思想纳入其中。   用户系统 需要用户系统，用户是系统的根源，是数据的源头，该系统的用户就是要求中所说的会员，所以需要提供如下功能：  用户注册 用户登录 用户信息查看 用户既可以是卖家，亦可以是买家  用户留言(信息反馈)为了逐渐完善系统，提供用户与建站者的交流通道，并且该通道不仅限于用户与建站者，用户与用户之间也能够互相交流，提高趣味性。具体功能如下：  用户留言 留言查看  卖家买家系统买卖离不开卖家买家，该系统亦是如此，需要如下功能列表：  卖家 图书上架 图书修改 图书查看 销售情况图表   买家 图书查看购买 买书记录查看 图书评论与删除     设计文档该部分将涉及整个系统从无到有的设计思路，自底向上有  数据库选择和设计 服务器框架选择和设计 前端框架选择和设计  并且将针对具体细节给出相关表示，如数据字典，ER图，数据流图，算法设计等。 数据库选择和设计选择与原因该系统我选择了MySQL数据库，具体原因如下：  MySQL十分轻量，相比课堂上讲的SQL Server数据库，一个安装包2GB，MySQL的500MB简直小巫见大巫（最近看到属于NoSQL的MongoDB居然只有100MB）。 短时间需要完成该系统，同时对于MySQL十分熟悉，之前做在线订票系统，在线考试系统等都是建立在MySQL上。 具有SQLYog这种强大方便的图形操作软件，轻松导入导出数据，轻松连接远程服务器传递数据。  基于以上原因，因此选择了MySQL。 数据字典 用户    字段 类型 备注     username varchar(12) 用户名,唯一, 6-12位   email varchar(20) 电子邮箱,唯一   password varchar(12) 密码,6-12位   registerDate date 注册日期     留言    字段 类型 备注     username varchar(12) 留言者用户名   content text 留言内容   datetime datetime 留言时间     图书    字段 类型 备注     bookID char(8) 图书ID,唯一,如BK123456   title varchar(25) 书名   author varchar(25) 作者   press varchar(25) 出版社   price decimal(10,1) 价格,保留小数点后一位   quantity int(11) 库存量(本)   image mediumblob 封面图片   seller varchar(12) 卖家用户名   importDate date 上架日期     图书评论    字段 类型 备注     username varchar(12) 评论人用户名   bookID char(8) 被评论图书   datetime datetime 评论时间   content text 评论内容     交易因为交易完成后，卖家仍然可以对图书进行修改，所以我将买进时图书信息都存放在此表中，表示买进时图书的信息。    字段 类型 备注     tradeID char(10) 交易记录ID,唯一,如TD12345678   tradeDate date 交易日期   buyer varchar(12) 买家用户名   bookID char(8) 书本ID   title varchar(25) 书名   author varchar(25) 作者   press varchar(25) 出版社   price decimal(10,1) 买进价格   quantity int(11) 库存   image mediumblob 封面   seller varchar(12) 卖家    E-R图 服务器框架选择和设计选择与原因作为JS动态语言的受益者，我服务器肯定就选择nodejs了。  未使用过nodejs开发一个相对完整的系统，打算就将该系统作为入门了。 nodejs非常适合IO密集型的应用，采用的是异步事件队列的机制。 JS语言简洁灵活有趣。  nodejs与express nodejs基于ChromeV8引擎，以JS作为宿主语言的一个虚拟环境，JS于NodeJs可以看做是Java于JVM，NodeJs现在正在不断发展中，目标是与Java一样，能够形成一套十分完备的库，目前NodeJs的生态环境非常好，第三方模块层出不穷，而且由于npm，这些包是否方便管理与下载。 express介绍完nodejs，那么express是什么呢？express是nodejs的一个第三方Web框架，开发者可以用该框架非常方便有效的建立HTTP服务。  结构设计文件结构db/ 所有数据库操作代码public/ 静态资源库，如js,cssroutes/ 路由操作diam，对应urlutils/ 工具包代码views/ Jade模板文件app.js 系统入口mysql.sql mysql数据文件，可导入 部分数据流图 用户留言 卖家添加图书 买家购书  部分算法设计首先对于留言评论，防止恶意用户刷留言评论，设置了定时销毁器。算法设计如下：12345678910111213141516171819202122var _timer = {};var Timer = { set : function (key,mill) { //设置定时器的关键字与销毁时间 this.remove(key); _timer[key] ={mill:mill}; _timer[key].code = setTimeout(function () { delete _timer[key]; },mill); }, isExist : function(key){ return !!_timer[key]; }, remove : function(key){ if(this.isExist(key)){ clearTimeout(_timer[key].code); delete _timer[key]; return true; } return false; }} 该系统具有销售分析，如某卖家所有销售情况的折线图，x轴表示日期，y轴表示该日售出书籍数目。算法设计如下：12345678910111213141516// all 表示所有卖家销售记录，0-N 时间从现在到以前function makeLineChart(all) { if(all==null || all.length==0) return; //返回数据中 keys表示日期数组，data表示对应keys日期的销售量 return all.reduceRight((p,n)=>{ // 从右向左归并 var date = n.tradeDate; if(p.keys[p.keys.length-1]!=date){ p.keys.push(date); p.data.push(1); }else{ p.data[p.data.length-1]++; } return p;  },{keys:[],data:[]});} 销售分析中还具有周最受欢迎图书饼图，表示一周内各个图书销售情况。算法设计如下：12345678910111213141516171819202122// all 表示所有卖家销售记录，0-N 时间从现在到以前function makePieChart(all) { if(all==null || all.length==0) return; var pivot = all[all.length-1]; // 取出最后一个交易记录，也就是最近的 var end = new Date(pivot.tradeDate).setHours(24); // 根据最近时间的时间得到第二天0点时间 var start = new Date(end - 1000*60*60*24*7); // 减去7天毫秒数，得到七天前时间 var data = {keys:[pivot.title],data:[1]},titleMap = {}; titleMap[pivot.title]=0; //初始化参数 for(var i=all.length-2;i>=0;i--){ if(new Date(all[i].tradeDate)<start) // 如果时间再七天之前，跳出循环 break; var title = all[i].title; if(titleMap[title]==null){ titleMap[title] = data.keys.length; data.keys.push(title); data.data.push(1); }else data.data[titleMap[title]]++; } return data;} 前端框架选择和设计选择与原因针对于用户之间接触的前端界面，我选择了Bootstrap3.0 UI，jQuery，marked.js，highlight.js，pace.js，下面做出相关介绍与说明：  BootStrap3.0一套完备的UI框架，包括美观的css样式和一些基于jQuery的组件。可以让开发者用最少的时间建立一个美观的界面。 jQuery因为BootStrap组件需要，而且能够方便进行DOM操作，强大的选择器与链式调用。 marked.js一个将markdown文本翻译为HTML的库，api简单。 highlight.js与marked.js配套使用，能够将代码段解析为具有样式类的库。 pace.js通过检查浏览器加载的状态，判断文档加载进度，并且提供了一系列的css样式，能够在页面加载的时候显示页面加载进度。  文件结构1234567891011121314151617public/├── javascripts/│ ├── addbook.js│ ├── Ajaxdelete.js│ ├── indexjs.js│ ├── msgAnimate.js│ ├── msgjs.js│ ├── popImage.js│ ├── search.js│ ├── selljs.js│ ├── utils.js└── stylesheets/ ├── bootstrap/ ├── style.less ├── style.css ├── hljs-github-min.css └── markdown.less stylesheets/文件夹放的是样式文件，其中的style.less是入口，style.css是利用node模块压缩后真正传送的样式文件 特殊功能说明 提示框动态固定显示方法一：（固定width）1234567891011121314151617.messages{ .box-shadow(0px 0px 8px 3px #bbb); z-index: 10000; position: fixed; width: 340px; height: 50px; left: 50%; top : -50px; margin-left: -170px; -webkit-transition: all 2s; -moz-transition: all 2s; -ms-transition: all 2s; -o-transition: all 2s; transition: all 2s; opacity:0;}   1234window.onload = function () { $('.messages') .css({'transform':'translate(0,120px)',opacity:1})} 方法二：width自适应12345678910111213141516171819.messages{ .box-shadow(0px 0px 8px 3px #bbb); z-index: 10000; position: fixed; left: 50%; top : 0px; -webkit-transform: translate(-50%,-50%); -moz-transform: translate(-50%,-50%); -ms-transform: translate(-50%,-50%); -o-transform: translate(-50%,-50%); transform: translate(-50%,-50%); -webkit-transition: all 2s; -moz-transition: all 2s; -ms-transition: all 2s; -o-transition: all 2s; transition: all 2s; opacity:0;} 12345window.onload = function () { $('.messages') // .css({'transform':'translate(0,120px)',opacity:1}) .css({'margin-top':'140px',opacity:1})}  跳至评论，评论区高亮123456789101112131415@keyframes blinking { 0% { //opacity: 0; } 30%{ background-color: #fcf8e3; } 100% { background-color: #fcf8e3; //opacity: 1; }}.blink{ .animation(blinking 2.8s)}   123456$('[role=link-msg]').click(function (e) { var x = $(this.hash).next().children().removeClass('blink') setTimeout(function () { x.addClass('blink').children('textarea').focus(); },0) });  markdown编辑区可粘贴网络图片 123456789101112131415input.onpaste = function (e) { var clipboardData, pastedData; // Get pasted data via clipboard API clipboardData = e.clipboardData || window.clipboardData; var text = clipboardData.getData('text/plain'); if(!text){ var img = clipboardData.getData('text/html'); img.replace(/<img.+src=\"(.+?)\"/g,(m,c)=>{ e.preventDefault(); // 调用 document.execCommand('insertText', false, \"![ClipboardImage](\"+c+\")\"); }) } };  代码段右上角显示语言    系统截图           收获与体会 感受到了nodejs与express的魅力 增强了系统的整体把控架构能力 掌握了一些常见具体问题的处理方式 不足在于后端异步结构代码比较冗杂，难于管理  参考资料 nodejs express4.x 文件上传 Jade 完整教程 page.js javascript-get-clipboard-data-on-paste-event-cross-browser www.haorooms.com/post/jq_js_xxjdt  ",
            "path": "/2016/06/20/图书销售系统（书窝）/"
        },
        {
            "title": "「项目拾遗」http文件浏览（静态文件+express4.x+md/code文件渲染）",
            "date": "2016-06-10",
            "content": " 问题暴露之前做的HTTP浏览是使用express2.x版本做的…，因为参考书比较旧了。  express2.x中没有express4.x中的res.sendFile()方法，之前发送文件是使用的stream.pipe()方法，导致不支持继续下载，而且用户不能知道下载进度，在线音乐视频播放也不能选择时间跳跃欣赏。res.sendFile()方法可以将本地文件以静态资源发送给用户，所有问题迎刃而解。 旧版本不支持java/c/cpp/js/css/html等代码文件和md/markdown文件在线查看，所以进行改进。 利用Bootstrap responsive utils和Bootstrap grid system进行响应式布局。 监控root.txt文件，改变root后无需重启服务器。 去除对q.js依赖，使用原生Promise   效果预览 json文件查看 md文件查看 html文件查看  代码改进root.txt文件监控123456//全局对象global.root = fs.readFileSync('./root.txt').toString().split(/\\s+/)[0];fs.watchFile('./root.txt',function () { //root.txt 文件修改后触发 global.root = fs.readFileSync('./root.txt').toString().split(/\\s+/)[0];}); 原生Promise1234567891011121314151617181920212223242526272829var statP = function(root,file){ return new Promise(function(resolve){ fs.stat(root+'/'+file,function (err, stats) { var t = {}; if(err){ t.reason=err; resolve(t); } else { t.state='ok'; stats.name = file; stats.type = stats.isDirectory()?'文件夹':'文件'; t.value=stats; resolve(t); } }); })};Promise.all(files.map((x,i,a)=>{return statP(r,x);})) .then(function (results) { var values = []; results.forEach(x=>{ if(x.state==='ok'){ values.push(x.value); }else console.error(x.reason); }); //...render },console.error); sendFile方法使用12345678910111213141516171819202122232425262728293031323334353637383940// noraw为url上的noraw参数值if(!!noraw){ // f为文件名 if(f.match(/\\.(avi|mp4|mkv|rmvb|mpg|rm|wma)$/i)){ res.render('video',o); }else if(f.match(/\\.(jpg|png|bmp|jpeg|gif)$/i)){ res.render('img',o); }else if(f.match(/\\.(mp3|wma|aac)$/i)){ res.render('audio',o); }else if(f.match(/\\.(md|markdown)$/i)){ fs.readFile(file,(error,data) => { if(error) throw error; o.content = data.toString(); res.render('md',o); }); }else if(f.match(/\\.(java|c|cpp|js|css|jsp|php|json|txt)$/i)){ fs.readFile(file,(error,data) => { if(error) throw error; // 在服务器渲染高亮代码方法被淘汰，因为对大文件调用下面方法十分耗时间， // 而node为单线程，所以其他用户请求也会被阻塞，而且本用户也要等待很久。 // 所以选择在浏览器端解析。 // console.time('hl'); // o.content=hl.highlightAuto(data.toString()).value; // console.timeEnd('hl'); o.content = data.toString(); res.render('code',o); }); }else if(f.match(/\\.(html|htm)$/i)){ fs.readFile(file,(error,data) => { if(error) throw error; o.content = data.toString(); res.render('html',o); }); }else{ // rela 为相对路径，root 为文件根目录 res.sendFile(rela,{root:global.root}); }}else{ res.sendFile(rela,{root:global.root});} layout.jade1234567891011121314doctypehtml(lang=\"zh\") head title= title meta(name=\"renderer\",content=\"webkit\") meta(http-equiv=\"X-UA-Compatible\",content=\"IE=edge\") meta(name=\"viewport\" content=\"width=device-width, initial-scale=1\") link(rel='stylesheet', href='/stylesheets/bootstrap.min.css') link(rel='stylesheet', href='/stylesheets/style.css') link(rel='stylesheet', href='/stylesheets/hljs-github.min.css') link(rel='stylesheet', href='/stylesheets/pilcrow.css') link(rel='stylesheet', href='/stylesheets/github-markdown.css') body block content code.jade12345678910111213extends layoutblock content script(src=\"http://cdn.bootcss.com/highlight.js/8.0/highlight.min.js\") div.container-fluid h1=title include btns div.markdown-body pre code!=content script hljs.initHighlightingOnLoad();//自动寻找<pre><code></code></pre>进行解析 footer p.text-center.text-info Running on node with Express, Jade. By Moyu. md.jade123456789101112131415161718192021222324// Created by Yc on 2016/6/9.extends layoutblock content script(src=\"http://cdn.bootcss.com/marked/0.3.5/marked.min.js\") script(src=\"http://cdn.bootcss.com/highlight.js/8.0/highlight.min.js\") div.container-fluid h1=title include btns div.row div.col-lg-6.visible-lg h2 解析前 div.markdown-body pre code(id='markdown-raw')=content //\"=\"会被转义(如 < : &lt;),\"!=\"不会 div.col-lg-6 h2 解析后 div.markdown-body(id='markdown-show') script(src=\"/javascripts/md.js\") //renderer 来自md.js script document.getElementById('markdown-show').innerHTML = marked(document.getElementById('markdown-raw').innerText,{renderer:renderer}); footer p.text-center.text-info Running on node with Express, Jade. By Moyu. md.js123456789101112131415161718192021222324~function(){ marked.setOptions({ highlight: function (code) { return hljs.highlightAuto(code).value; } }); renderer = new marked.Renderer(); var map = {}; //重写默认'#','##'... 格式的转换方法 renderer.heading = function (text, level) {//level 表示层级，如#为1，##为2 var escapedText = text.toLowerCase(); // 防止出现重复的锚点 if(!!map[text]) escapedText+='-'+map[text]++; else map[text]=1; return '<h' + level + '><a name=\"' + escapedText + '\" class=\"anchor\" href=\"#' + escapedText + '\"><span class=\"header-link\"></span></a>' + text + '</h' + level + '>'; };}(); 问题归纳通过url的noraw控制展示方式，对SEO不友好GitHub的解决方法是，在raw文件提供独立的三级域名raw.githubusercontent.com/{username}/{repo}/{branch}/{file} 后期希望更加完善这个web应用吧，比如在线查看压缩文件等功能。 代码地址http-file-explorer-express4.x 参考资料 markdown-styles: 提供高大上的CSS样式。 marked: 提供强大的markdown格式转化API。 highlight.js: 提供强大的code格式转化为具有class样式的标签，方便用户自定义样式。 express4.x: express4.x详细API文档。  ",
            "path": "/2016/06/10/「项目拾遗」HTTP文件浏览（静态文件-express4-x-md-code文件渲染）/"
        },
        {
            "title": "「思科模拟器」建立dns+http服务",
            "date": "2016-06-06",
            "content": " 引言之前，我介绍了使用思科构建VLAN服务，下面我将介绍利用思科建立DNS/HTTP服务。 操作流程DNS服务搭建网络布局如图，构建网络 IP设置其中各结点ip如下表所示    # IP 默认网关 DNS服务器     Client 10.0.0.2 10.0.0.1 10.0.0.3   Local DNS Server 10.0.0.3 10.0.0.1 -   Company Router Left 10.0.0.1 - -   Company Router Right 10.1.0.1 - -   Internet Router Left 10.1.0.2 - -   Internet Router Right 10.3.0.1 - -   Internet Router Down 10.2.0.1 - -   Root DNS Server 10.2.0.2 10.2.0.1 -   Example Router Left 10.3.0.2 - -   Example Router Right 10.4.0.1 - -   Other Server 10.4.0.2 10.4.0.1 -   Yucong DNS Server 10.4.0.3 10.4.0.1 -    DNS解析表填写Local DNS Server Root DNS Server Yucong DNS Server 域名解析测试对Client进行Ping指令测试，结果如下图说明成功搭建DNS服务！ DNS Cache查看如上图，为Local DNS Server的DNS缓存，下次访问相同域名时，直接取出即可。 HTTP服务搭建在上面的基础上，完成HTTP服务器搭建 开启服务若我想以Other Server作为HTTP服务器，进行如下设置即可 网页测试对Client打开Web Browser，输入other.yucong.com如图，正常访问！ ",
            "path": "/2016/06/06/「思科模拟器」建立DNS-HTTP服务/"
        },
        {
            "title": "「项目拾遗」简单图形处理及图形绘制",
            "date": "2016-06-03",
            "content": " 引言 这个学期，我学习了图像处理的相关课程，对图像有了初步的认识，并且利用web知识，做了相关实践。 在线地址：moyuyc.github.io/htm/painter/ 姓名：余聪学号：19130126 实现技术说明 使用了前端HTML5 canvas API 以及后端Java Web搭建的后台服务。 也就是说，图像处理功能既有使用JavaScript语言实现的，也有利用Java语言实现的，但是都将以网页形式展现 具体技术说明如下图所示。  使用说明 Image Choose  点击白色面板，选择图像起点  右侧Message出现该图片灰度分布情况 操作面板解释  注意 对于Server操作，由于需要将图像传输给服务器，所以对于图像大小有要求，请使用下面的图片(较小)进行测试   功能介绍设置图像透明度(直接像素点操作) 如图  代码 12345678910111213141516171819alphaHandle = function () { setImageAlpha = function(index,alph){ if(paint.images && paint.images.length>index ) { var image = paint.images[index], img = paint.getImageData(image.x,image.y,image.width,image.height); for(var i=0;i<img.data.length;i+=4){ // 设置alph img.data[i+3] = alph; } paint.save(); paint.putImageData(img,image.x,image.y); paint.restore(); } }; var alph; while((alph=parseInt(prompt('please set images alpha. (0~255)',120)))>255 || alph<0); for(var i=0;i<paint.images.length;i++) setImageAlpha(i,alph);};   图像灰化(直接像素点操作) 如图  代码 1234567891011imgGrayHandle = function () { paint.images.forEach(function (ele) { var imgData = paint.getImageData(ele.x,ele.y,ele.width,ele.height); for (var i=0;i<imgData.data.length;i+=4) { var r = imgData.data[i],g=imgData.data[i+1],b = imgData.data[i+2]; var value = (r+g+b)/3; //rgb平均值->灰度 imgData.data[i]=imgData.data[i+1]=imgData.data[i+2]=value; } paint.putImageData(imgData,ele.x,ele.y); })};   高对比度(直接像素点操作) 如图  代码 123456789101112hgHandle = function () { paint.images.forEach(function (ele) { var imgData = paint.getImageData(ele.x,ele.y,ele.width,ele.height); for (var i=0;i<imgData.data.length;i+=4) { // 取背景色的反作为前景色 imgData.data[i] = 255-imgData.data[i]; imgData.data[i+1] = 255-imgData.data[i+1]; imgData.data[i+2] = 255-imgData.data[i+2]; } paint.putImageData(imgData,ele.x,ele.y); })};   浮雕效果(锐化滤波器) 如图  代码 1234567891011121314151617181920212223function ConvolutionMatrix(input, matrix, divisor, offset) { // 创建一个输出的 imageData 对象 var output = document.createElement(\"canvas\") .getContext('2d').createImageData(input); var w = input.width, h = input.height; var iD = input.data, oD = output.data; var m = matrix; // 对除了边缘的点之外的内部点的 RGB 进行操作，透明度在最后都设为 255 for (var y = 1; y < h - 1; y += 1) { for (var x = 1; x < w - 1; x += 1) { for (var c = 0; c < 3; c += 1) { var i = (y * w + x) * 4 + c; oD[i] = offset + (m[0] * iD[i - w * 4 - 4] + m[1] * iD[i - w * 4] + m[2] * iD[i - w * 4 + 4] + m[3] * iD[i - 4] + m[4] * iD[i] + m[5] * iD[i + 4] + m[6] * iD[i + w * 4 - 4] + m[7] * iD[i + w * 4] + m[8] * iD[i + w * 4 + 4]) / divisor; oD[(y * w + x) * 4 + 3] = 255; // 设置透明度 } } } return output;};   图像黑化(直接像素点操作) 如图  代码 123456789101112blackHandle = function () { paint.images.forEach(function (ele) { var imgData = paint.getImageData(ele.x,ele.y,ele.width,ele.height); for (var i=0;i<imgData.data.length;i+=4) { var r = imgData.data[i],g=imgData.data[i+1],b = imgData.data[i+2]; var grey = r*0.3+g*0.59+b*0.11; // 取0或者255,非黑即白 imgData.data[i] = imgData.data[i+1] = imgData.data[i+2] = grey>125 ? 255 : 0; } paint.putImageData(imgData,ele.x,ele.y); })}   模糊效果(线性平滑滤波器) 如图  代码 12345678910111213141516171819202122232425blurHandle = function (){ paint.images.forEach(function (ele) { var imgData = paint.getImageData(ele.x, ele.y, ele.width, ele.height); var blurR = 3, totalnum = (2 * blurR + 1) * (2 * blurR + 1); for (var i = blurR; i < ele.height - blurR; i++) for (var j = blurR; j < ele.width - blurR; j++) { var totalr = 0, totalg = 0, totalb = 0; //2*blurR 模糊的正方形长宽，total 范围内RGB的总和 for (var dx = -blurR; dx <= blurR; dx++) for (var dy = -blurR; dy <= blurR; dy++) { var x = i + dx var y = j + dy var p = (x * ele.width + y)*4; totalr += imgData.data[p + 0] totalg += imgData.data[p + 1] totalb += imgData.data[p + 2] } var p = (i*ele.width + j)*4; imgData.data[p+0] = totalr / totalnum; imgData.data[p+1] = totalg / totalnum; imgData.data[p+2] = totalb / totalnum; } paint.putImageData(imgData,ele.x,ele.y); });};   马赛克效果(平滑滤波器) 如图  代码 123456789101112131415161718192021222324252627282930313233343536mosaicHandle = function (){ paint.images.forEach(function (ele) { var imgData = paint.getImageData(ele.x, ele.y, ele.width, ele.height); var size = 16 var totalnum = size*size; for( var i = 0 ; i < ele.height ; i += size ) for( var j = 0 ; j < ele.width ; j += size ){ var totalr = 0 , totalg = 0 , totalb = 0 //以size为大小作为一个像素方格 for( var dx = 0 ; dx < size ; dx ++ ) for( var dy = 0 ; dy < size ; dy ++ ){ var x = i + dx; var y = j + dy; var p = x*ele.width + y totalr += imgData.data[p*4+0] totalg += imgData.data[p*4+1] totalb += imgData.data[p*4+2] } var p = i*ele.width+j var resr = totalr / totalnum var resg = totalg / totalnum var resb = totalb / totalnum; //将size大小内的像素点全部设为平均rgb for( var dx = 0 ; dx < size ; dx ++ ) for( var dy = 0 ; dy < size ; dy ++ ){ var x = i + dx var y = j + dy var p = x*ele.width + y imgData.data[p*4+0] = resr imgData.data[p*4+1] = resg imgData.data[p*4+2] = resb } } paint.putImageData(imgData,ele.x,ele.y); })}   KMenus算法(矢量量化) 说明：KMenus算法是一个聚类算法，我们可以用该算法思想，找出图像中主要的rgb颜色。（可以将rgb想象为三维空间xyz，找出图像中rgb聚集的地方）然后把属于该聚类中的所有像素点全部赋值为聚类像素值，查看效果 如图  代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162kMeans : function(imgData){ var data = imgData.data, w = imgData.width, h = imgData.height; var clusters = (function getRandomClusters(k){ var rlt = []; while(k-->0) rlt.push([randomInt(256),randomInt(256),randomInt(256)]); return rlt; })(3); function getRGBDistance(clu,rgb){ return parseInt(Math.sqrt(Math.pow(rgb[0]-clu[0],2)+Math.pow(rgb[1]-clu[1],2),Math.pow(rgb[2]-clu[2],2)).toFixed(0)); } function getCenterCluster(rgbs){ var sumr= 0,sumg= 0,sumb=0; for(var i in rgbs){ sumr+=rgbs[i][0];sumg+=rgbs[i][1];sumb+=rgbs[i][2]; } return [parseInt((sumr/rgbs.length).toFixed(0)), parseInt((sumg/rgbs.length).toFixed(0)), parseInt((sumb/rgbs.length).toFixed(0))] } var forNewClus = new Array(clusters.length),forNewData = new Array(clusters.length); while(true) { for(var i=0;i<forNewClus.length;i++) { forNewClus[i] = []; forNewData[i] = []; } for (var i = 0; i < data.length; i += 4) { var myCluIndex, minDist = Number.MAX_VALUE, rgb = [data[i], data[i + 1], data[i + 2]]; for (var j = 0; j < clusters.length; j++) { var dist = getRGBDistance(clusters[j], rgb); if (dist < minDist) { myCluIndex = j; minDist = dist; } } forNewData[myCluIndex].push(i); forNewClus[myCluIndex].push(rgb); } var isUpdate=false; for(var i=0;i<forNewClus.length;i++) { if(forNewClus[i].length==0) continue; var c = getCenterCluster(forNewClus[i]); if(c[0]!=clusters[i][0]||c[1]!=clusters[i][1]||c[2]!=clusters[i][2]) { clusters[i] = c; isUpdate = true; } } if(!isUpdate) break; } for(var i=0;i<forNewData.length;i++) { for(var j=0;j<forNewClus[i].length;j++){ var val = forNewData[i][j]; data[val] = clusters[i][0]; data[val+1] = clusters[i][1]; data[val+2] = clusters[i][1]; } } console.log(forNewClus,clusters); return {c:clusters,md:imgData}; }   直方图均衡化(空域点处理) 说明：直方图均衡化：我们把一张图片对应的rgb像素点分成3个(对应rgb)256(0-255)等级，并且将等级绘制为直方图，我们把直方图变得分布均匀，这就是直方图均衡化。这样的图片往往具有高对比度。 如图  代码 1234567891011121314151617181920212223242526272829303132333435363738394041//http://blog.csdn.net/jia20003/article/details/8119563//http://hello-wangfeng.iteye.com/blog/1717150average: function (imgData) { var data = imgData.data, w = imgData.width, h = imgData.height; var histogramR = [], histogramG = [], histogramB = []; for(var i=0; i<data.length; i+=4){ histogramR[data[i]] = histogramR[data[i]]+1 || 1; histogramG[data[i+1]] = histogramG[data[i+1]]+1 || 1; histogramB[data[i+2]] = histogramB[data[i+2]]+1 || 1; } //直方图均衡化 function getRate(grayHis,total,index) { var s = 0; for(var i=0;i<index;i++){ var v = grayHis[i]||0; s+=(v/total); } return Math.floor(s*255); } var total = w*h, newHisR = [], newHisG = [], newHisB = []; for(i=0; i<256; i++){ newHisR[i] = getRate(histogramR,total,i); newHisG[i] = getRate(histogramG,total,i); newHisB[i] = getRate(histogramB,total,i); } console.log([histogramR,histogramG,histogramB],[newHisR,newHisG,newHisB]); for(i=0; i<h; i++){ for(var j=0; j<w; j++){ var v = (i*w+j)<<2; data[v] = newHisR[data[v]]; data[v+1]=newHisG[data[v+1]]; data[v+1]=newHisB[data[v+2]]; } } return imgData;}   图像复原 说明：图像在形成、记录、处理和传输过程中，由于成像系统、记录设备、传输介质和处理方法的问题，导致图像质量下降，这种现象叫图像退化。而图像复原就是对退化的图像进行处理，尽可能的复原图像的本来面目。 如图   代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//图像恢复public int[] imRestore(int[] pixels, int iw, int ih){ double[] newPixels = new double [iw*ih]; double[] newKernel = new double [iw*ih]; //初始化 for(int j = 0; j < ih; j++) { for(int i = 0; i < iw; i++) { newPixels[i+j*iw] = pixels[i+j*iw]&0xff; if((i<5) && (j<5)) newKernel[i+j*iw] = 1.0/25; else newKernel[i+j*iw] = 0; } } //初始化 Complex[] complex = new Complex[iw*ih]; Complex[] comKernel = new Complex[iw*ih]; for(int i = 0;i < iw*ih; i++) { complex[i] = new Complex(0,0); comKernel[i] = new Complex(0,0); } //对原图像进行FFT (快速傅氏变换) fft2 = new FFT2(); fft2.setData2(iw, ih, newPixels); complex = fft2.getFFT2(); //对卷积核进行FFT fft2 = new FFT2(); fft2.setData2(iw, ih, newKernel); comKernel = fft2.getFFT2(); //逆滤波复原 for(int j = 0;j < ih; j++) { for(int i = 0; i < iw; i++) { double re = complex[i+j*iw].re; double im = complex[i+j*iw].im; double reKernel = comKernel[i+j*iw].re; double imKernel = comKernel[i+j*iw].im; double x = reKernel*reKernel+imKernel*imKernel; if(x > 1e-3) { double r = (re*reKernel+im*imKernel)/x; double m = (im*reKernel-re*imKernel)/x; complex[i+j*iw].re = r; complex[i+j*iw].im = m; } } } //进行FFT反变换 fft2 = new FFT2(); fft2.setData2i(iw, ih, complex); pixels = fft2.getPixels2i(); return pixels;}   边界检测(自定义方法) 说明：人们看一个物体是，首先感受的就是它的边缘，灰度或结构等信息的突变处称为边缘。边缘是一个区域的结束，也是另一个区域的开始，利用这种特征可以分割图像。 物体边缘上的这种变化可以用微分算子检测出来，通常用一阶或二阶导数来检测边缘。 如图  代码 123456789101112131415161718192021222324252627282930313233343536373839//边界提取public byte[] Bound(byte bw[], int iw, int ih){ int p, r; byte[] tem = new byte[iw*ih]; for(int j = 0;j < ih; j++) for(int i = 0; i < iw; i++) tem[i+j*iw] = bw[i+j*iw]; for(int j = 1; j < ih - 1; j++) { for (int i = 1; i < iw - 1; i++) { p = bw[i+j*iw]; if(p == 0)//如果当前象素是白色, 进入下一个循环 continue; else { // 检查周边的8-连通域 r = 1; LB: for(int k =-1;k<2;k++) { for(int l=-1;l<2;l++) { if(bw[i+k+(j+l)*iw] == 0) { r = 0; break LB;//跳出2重循环 } } } //如果都是黑点,判定为内部点,改变颜色 if(r == 1) tem[i+j*iw] = 0; } } } return tem;}   素描效果(roberts边界检测) 说明：上面说到边缘可以用微分算子检测，roberts算子就是基于一阶导数的边缘检测算子的一种。 如图  代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445//Roberts算法public int[] robert(int[] px, int iw, int ih, int thresh, boolean flag){ ColorModel cm = ColorModel.getRGBdefault(); int r, r0, r1, r2, r3, g, g0, g1, g2, g3, b, b0, b1, b2, b3; for(int j = 1; j < ih-1; j++) { for(int i = 1; i < iw-1; i++) { r0 = cm.getRed(px[i+j*iw]); r1 = cm.getRed(px[i+(j+1)*iw]); r2 = cm.getRed(px[i+1+j*iw]); r3 = cm.getRed(px[i+1+(j+1)*iw]); /*--------------------------------------------* * ------------------------- * |r0:(i,j) |r1:(i, j+1) | * |-----------------------| 交叉 * |r2:(i+1,j)|r3:(i+1,j+1)| * ------------------------- *--------------------------------------------*/ r = (int)Math.sqrt((r0-r3)*(r0-r3)+(r1-r2)*(r1-r2)); g0 = cm.getGreen(px[i+j*iw]); g1 = cm.getGreen(px[i+(j+1)*iw]); g2 = cm.getGreen(px[i+1+j*iw]); g3 = cm.getGreen(px[i+1+(j+1)*iw]); g = (int)Math.sqrt((g0-g3)*(g0-g3)+(g1-g2)*(g1-g2)); b0 = cm.getBlue(px[i+j*iw]); b1 = cm.getBlue(px[i+(j+1)*iw]); b2 = cm.getBlue(px[i+1+j*iw]); b3 = cm.getBlue(px[i+1+(j+1)*iw]); b = (int)Math.sqrt((b0-b3)*(b0-b3)+(b1-b2)*(b1-b2)); if(flag) { if(r > thresh) r = 0;//黑色，边缘点 else r = 255; px[i+j*iw] = (255<<24)|(r<<16)|(r<<8)|r; } else px[i+j*iw] = (255<<24)|(r<<16)|(g<<8)|b; } } return px;}   其他 清空画板 选择图片下载 画板图片下载 添加文字 图形绘制，图形拖拽，图形填充  参考资料 数字图像处理——Java编程与实验 （孙燮华著）  ",
            "path": "/2016/06/03/「项目拾遗」简单图形处理及图形绘制/"
        },
        {
            "title": "「图像处理」图像的复原",
            "date": "2016-06-03",
            "content": " 介绍图像在形成、记录、处理和传输过程中，由于成像系统、记录设备、传输介质和处理方法的问题，导致图像质量下降，这种现象叫图像退化。而图像复原就是对退化的图像进行处理，尽可能的复原图像的本来面目。如图，先对图片进行模糊处理然后对图片进行还原 代码解释1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 //图像恢复public int[] imRestore(int[] pixels, int iw, int ih){ double[] newPixels = new double [iw*ih]; double[] newKernel = new double [iw*ih]; //初始化 for(int j = 0; j < ih; j++) { for(int i = 0; i < iw; i++) { newPixels[i+j*iw] = pixels[i+j*iw]&0xff; if((i<5) && (j<5)) newKernel[i+j*iw] = 1.0/25; else newKernel[i+j*iw] = 0; } } //初始化 Complex[] complex = new Complex[iw*ih]; Complex[] comKernel = new Complex[iw*ih]; for(int i = 0;i < iw*ih; i++) { complex[i] = new Complex(0,0); comKernel[i] = new Complex(0,0); } //对原图像进行FFT (快速傅氏变换) fft2 = new FFT2(); fft2.setData2(iw, ih, newPixels); complex = fft2.getFFT2(); //对卷积核进行FFT fft2 = new FFT2(); fft2.setData2(iw, ih, newKernel); comKernel = fft2.getFFT2(); //逆滤波复原 for(int j = 0;j < ih; j++) { for(int i = 0; i < iw; i++) { double re = complex[i+j*iw].re; double im = complex[i+j*iw].im; double reKernel = comKernel[i+j*iw].re; double imKernel = comKernel[i+j*iw].im; double x = reKernel*reKernel+imKernel*imKernel; if(x > 1e-3) { double r = (re*reKernel+im*imKernel)/x; double m = (im*reKernel-re*imKernel)/x; complex[i+j*iw].re = r; complex[i+j*iw].im = m; } } } //进行FFT反变换 fft2 = new FFT2(); fft2.setData2i(iw, ih, complex); pixels = fft2.getPixels2i(); return pixels;} ",
            "path": "/2016/06/03/「图像处理」图像的复原/"
        },
        {
            "title": "「图像处理」图像的直方图均衡化",
            "date": "2016-06-03",
            "content": " 介绍直方图均衡化：我们把一张图片对应的rgb像素点分成3个(对应rgb)256(0-255)等级，并且将等级绘制为直方图，我们把直方图变得分布均匀，这就是直方图均衡化。这样的图片往往具有高对比度，我使用js语言实现了该算法。 代码解释1234567891011121314151617181920212223242526272829303132333435363738394041average: function (imgData) { // imgData : 图片数据 var data = imgData.data, w = imgData.width, h = imgData.height; var histogramR = [], histogramG = [], histogramB = []; for(var i=0; i<data.length; i+=4){ // 统计rgb等级数目 histogramR[data[i]] = histogramR[data[i]]+1 || 1; histogramG[data[i+1]] = histogramG[data[i+1]]+1 || 1; histogramB[data[i+2]] = histogramB[data[i+2]]+1 || 1; } //直方图均衡化 function getRate(grayHis,total,index) { var s = 0; for(var i=0;i<index;i++){ var v = grayHis[i]||0; s+=(v/total); } return Math.floor(s*255); } var total = w*h, newHisR = [], newHisG = [], newHisB = []; for(i=0; i<256; i++){//直方图均衡化 newHisR[i] = getRate(histogramR,total,i); newHisG[i] = getRate(histogramG,total,i); newHisB[i] = getRate(histogramB,total,i); } console.log([histogramR,histogramG,histogramB],[newHisR,newHisG,newHisB]); for(i=0; i<h; i++){ for(var j=0; j<w; j++){ var v = (i*w+j)<<2; data[v] = newHisR[data[v]]; data[v+1]=newHisG[data[v+1]]; data[v+1]=newHisB[data[v+2]]; } } return imgData;} 查看控制台，左边为原图局部数据，右边为执行算法后的数据，明显后者分布更加平稳。 直观的感觉如下 参考资料 http://blog.csdn.net/jia20003/article/details/8119563 http://hello-wangfeng.iteye.com/blog/1717150  ",
            "path": "/2016/06/03/「图像处理」图像的直方图均衡化/"
        },
        {
            "title": "「思科模拟器」构建虚拟局域网（vlan）",
            "date": "2016-06-02",
            "content": " 前言思科模拟器是一款强大的模拟网络环境的软件，但是容量却不大，安装器只有70M左右，这篇文章将为你介绍利用思科模拟器构建VLAN网络。 正文如图，操作鼠标搭建如图简单的网络，用到了交换机（端口1-4）-直通线-普通终端。点击终端图标，进入终端配置界面，点击Desktop标签，点击IP Configuration，如下图，静态设置IP地址。配置完成后，你还可以进入终端的命令行界面(Command Prompt)，进行ping命令的测试，如下图然后，就是对于交换机进行配置了，建立不同的虚拟局域网。点击交换机图片，进入命令行界面，输入如下指令：123456789101112Switch(config)#vlan 1 #建立Vlan1，默认已经存在Switch(config-vlan)#exitSwitch(config)#vlan 2 #建立Vlan2Switch(config-vlan)#exitSwitch(config)#interface f0/1 #对1端口进行配置 Switch(config-if)#switchport access vlan 1 #将1端口加入vlan1，默认已经存在Switch(config-if)#interface f0/2Switch(config-if)#switchport access vlan 1Switch(config-if)#interface f0/3Switch(config-if)#switchport access vlan 2Switch(config-if)#interface f0/4Switch(config-if)#switchport access vlan 2 操作界面如下图所示：或者你可以利用图形界面进行操作 完成如上步骤后，你就完成了vlan的构建，下面进行测试。进入ip：192.168.100.11的终端命令行，进行ping指令测试。如下图，同属于vlan1的192.168.100.12能够ping通，但是valn2中的192.168.200.12不能够，所以测试正确。 总结初步见识到了思科模拟器的威力，之后还会带来更多的文章教学。 ",
            "path": "/2016/06/02/「思科模拟器」构建虚拟局域网（VLAN）/"
        },
        {
            "title": "「node网络编程」smtp客户端程序",
            "date": "2016-05-30",
            "content": " 前言本文介绍了node中net包使用，以及相关SMTP的知识。  知识介绍  如图,电子邮件服务的实现结构，我这里主要讲的是红色圆圈的内容。  下面是一次客户端成功发送QQ邮件的服务器响应和客户端请求的全过程。（数字开头的即为服务器响应）1234567891011121314151617181920212223242526272829303132333435363738394041424344HELO moyu220 smtp.qq.com Esmtp QQ Mail Server250 smtp.qq.comAUTH LOGIN334 VXNlcm5hbWU6xxxxxxxxxxxxxxxxxxxx #隐私内容，经过base64编码的用户名334 UGFzc3dvcmQ6xxxxxxxxxxxxxxxxxxx #隐私内容，经过base64编码的密码235 Authentication successfulMAIL FROM:492899414@qq.com250 OkRCPT TO:492899414@qq.com250 OkDATA354 End data with <CR><LF>.<CR><LF>From: MoyuSubject: Smtp Client implementationTo: 492899414@qq.comContent-Type: text/html<h1>HELLO SMTP</h1>.250 Ok: queued as QUIT221 Bye 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var net = require('net');function sendMail(host,user,pwd,to,msg) { var socket = net.createConnection(25,host); // 发送者用户名与密码需要base64编码发送 var user64 = new Buffer(user).toString(\"base64\");  pwd = new Buffer(pwd ).toString(\"base64\");  socket.on('connect',function () { this.write('HELO '+user+'\\r\\n'); }); var wt = net.Socket.prototype.write; socket.write = function () { console.log(arguments); return wt.apply(this,arguments); } var op = ['AUTH LOGIN\\r\\n']; socket.pipe(process.stdout); socket.on('data',function (data) { data = data.toString(); const code = data.match(/^\\d{3}/)[0] switch (code){ case '250':{ var v = op.shift(); if(v==='AUTH LOGIN\\r\\n'){ op.push(user64+'\\r\\n'); op.push(pwd+'\\r\\n'); }else if(v==='RCPT TO:'+to+'\\r\\n'){ op.push('DATA\\r\\n'); op.push(msg+'\\r\\n.\\r\\n'); } socket.write(v); break; } case '334':{ var v = op.shift(); socket.write(v); if(op.length===0) op.push('MAIL FROM:'+user+'\\r\\n'); break; } case '235': socket.write(op.shift()); op.push('RCPT TO:'+to+'\\r\\n'); break; case '221': socket.end(); break; case '354': socket.write(op.shift()); op.push('QUIT'+'\\r\\n'); break; // default : console.log(data); } })} 调用1234567891011sendMail( 'smtp.qq.com', '492899414@qq.com', 'xxxxxxx', '492899414@qq.com', \"From: Moyu\\r\\n\"+ \"Subject: Smtp Client implementation\\r\\n\"+ \"To: 492899414@qq.com\\r\\n\"+ \"Content-Type: text/html\\r\\n\\r\\n\"+ // 两个\\r\\n作为与正式数据的分割 \"<h1>Hello Moyu</h1>\"); 成功运行后，输出结果如下12345678910111213141516171819{ '0': 'HELO 492899414@qq.com\\r\\n' }220 smtp.qq.com Esmtp QQ Mail Server250 smtp.qq.com{ '0': 'AUTH LOGIN\\r\\n' }334 VXNlcm5hbWU6{ '0': 'NDkyODk5NDE0QHFxLmNvbQ==\\r\\n' }334 UGFzc3dvcmQ6{ '0': 'xxxxxxxxxxxxxxx\\r\\n' }235 Authentication successful{ '0': 'MAIL FROM:492899414@qq.com\\r\\n' }250 Ok{ '0': 'RCPT TO:492899414@qq.com\\r\\n' }250 Ok{ '0': 'DATA\\r\\n' }354 End data with <CR><LF>.<CR><LF>{ '0': 'From: Moyu\\r\\nSubject: Smtp Client implementation\\r\\nTo: 492899414@qq.com\\r\\nContent-Type: text/html\\r\\n\\r\\n<h1>Hello Moyu</h1>\\r\\n.\\r\\n' }250 Ok: queued as { '0': 'QUIT\\r\\n' }221 Bye 总结学习了node的相关网络编程，理解SMTP协议，自己造轮子。 ",
            "path": "/2016/05/30/「node网络编程」SMTP客户端程序/"
        },
        {
            "title": "「node网络编程」ftp客户端程序",
            "date": "2016-05-30",
            "content": " 前言最近，在「计算机网络」的课堂上，老师讲到了应用层相关的协议，FTP/HTTP/SMTP...理论结合实践才能产生最大的效益，所以我便利用nodejs中的net包，进行了相关的网络编程。  知识介绍  如图,FTP协议使用了2个tcp连接，一个是控制连接（服务器端默认端口为21），一个是数据传输连接（服务器端默认端口为20），客户端也需要对应的使用两个不同的端口进行连接。    如图  在服务器21端口有新的连接到来后，服务器发送220码响应 客户端利用该连接，向服务器21端口发送USER命令 服务器响应331 客户端发送PASS命令 服务器响应230 客户端发送PORT命令（客户选择端口号发送，服务器20端口将会与客户端该端口建立tcp连接，这就是数据传输连接） 服务器响应150 客户端发送TYPE命令（给服务器端口21，表示更改文件的类型） 服务器响应200 客户端发送STRU命令（给服务器端口21，表示更改文件的数据的组织） 服务器响应200 客户端发送STOR命令（给服务器端口21，表示发送文件至服务器） 服务器响应250 利用6中建立的数据传输连接传输数据 服务器响应226 客户端发送QUIT命令（给服务器端口21，表示断开连接） 服务器响应221   更多信息参考 代码12345678910111213141516171819202122232425262728var net = require('net');var socket = net.createConnection(21,'172.21.59.162');//new net.Stream();socket.on('connection',function () { console.log('connected');});socket.on('end',function () { console.log('disconnected');});process.stdin.pipe(socket).pipe(process.stdout);socket.write('USER anonymous\\r\\n');socket.write('PASS guest\\r\\n');socket.write('PWD\\r\\n');socket.write('PORT 172,21,59,162,34,184\\r\\n');//172,21,59,162:客户端IP 34,184:10进制表示端口，即34*256+184=8888// socket.write('LIST movie\\r\\n');//socket.write('TYPE I\\r\\n');socket.write('RETR bootstrap.zip\\r\\n');//下载服务器端文件// socket.write('LIST /FTP\\r\\n');const client = net.createServer(function (s) { console.log('client new connect'); s.on('connect',()=>{ console.info('client new connect'); }); s.pipe(require('fs').createWriteStream('ftpfile.zip'));//保存服务器服务器数据 s.on('error',console.error)}).listen(8888);//新的客户端端口 总结学习了node的相关网络编程，理解FTP协议，自己造轮子。 ",
            "path": "/2016/05/30/「node网络编程」FTP客户端程序/"
        },
        {
            "title": "node+express+jade实现http文件浏览器",
            "date": "2016-05-28",
            "content": " 前言我们有时候会有一个这样的需求，就是共享本地电脑的文件夹，方便在其他地方查看。那么，我们可以用现成的FTP协议，但是ftp协议约束太高，界面丑陋，而且功能不能扩展，所以，借着学习node的契机，我实践动手做了这个http文件浏览器。 预览 功能 支持图片，视频，音乐在线欣赏 支持文件夹压缩下载（管道流下载） 实现 安装express npm install -g express 快速创建应用 express http_file_explorer  之后就可以看到快速创建的http_file_explorer应用  在app.js入口文件中 1234567891011app.configure(function(){ app.set('views', __dirname + '/views'); app.set('view engine', 'jade'); app.use(express.bodyParser()); app.use(express.methodOverride()); //* 下面两个的顺序不能错，不然public文件夹中的资源请求也会被routes.index处理 app.use(express.static(__dirname + '/public')); app.use(app.router);});...app.get('/*', routes.index);//对所有url进行处理  关于routes/index.js 123456789101112131415161718192021222324252627var fs = require('fs');// 实现Promise标准的库，使得代码更优雅var Q = require('q');// 解析url信息var url = require('url');// 压缩功能使用的包var archiver = require('archiver');// 读取root，得到需要共享的文件夹路径var root = fs.readFileSync('./root').toString();exports.index = function(req, res){ // 解析url，得到参数等信息 var arg = url.parse(req.url,true), query = arg.query; // 将url路径解码，不然中文文件名出错 var r = decodeURIComponent(arg.pathname); r=r==='/'?'':r; console.info(r,query); if(!query.compress){//是否压缩下载？ var state = fs.statSync(root+r); if(state.isDirectory()) loadDir(root+r,r, req, res); else loadFile(root+r,r,query.raw,res); }else{ loadZip(root+r,r,req,res); }};  使用Promise，实现文件夹的同步读取可以参考Promise介绍与nodejs实践运用(q.js) 1234567891011121314151617181920212223242526272829303132333435363738394041var statPr = function (root,file) { var deferred = Q.defer(); fs.stat(root+'/'+file,function (err, stats) { if(err) deferred.reject(err); else { stats.name = file; stats.type = stats.isDirectory()?'文件夹':'文件'; deferred.resolve(stats, root); } }); return deferred.promise;};function loadDir(root,rela,req,res) { fs.readdir(root,function (err,files) { if(err) throw err; Q.allSettled(files.map((x,i,a)=>{return statPr(r,x);})) .then(function (results) { var values=[]; results.forEach(x=>{ if(x.state==='fulfilled'){ values.push(x.value); }else console.error(x.reason); }); res.render('file',Object.extend(o, { title:'HTTP文件查看', dirname:rela, files : values.map(x=> { return { type: x.type, name: x.name, time: x.mtime.format(), size: x.size.toSize() }; }) }) ); },console.error) });}  关于JadeJade是一个html模板，具有简洁的特点。关于Jade语法，参考Jade 模板引擎使用  关于压缩实现在这我是用了archiver模块，其实还有很多的压缩解压缩模块，参看更多 1234567891011var archiver = require('archiver');function loadZip(file,rela,req,res) { var state = fs.statSync(file); var filename = rela.substring(rela.lastIndexOf('/')+1); var archive = archiver('zip'); archive.on('error', function(err){throw err;}); archive.pipe(res); if(state.isDirectory()) archive.directory(file,filename); else archive.file(file,{name:filename}); archive.finalize();} 更多文档资料可以查看archiver  关于管道流下载文件传统的方法如下： 1234fs.readFile(path,function(err,data){ if(err) throw err; res.end(data);}) 传统方式将数据全部读取完毕后，才产生响应，第一，服务器需要花费较大内存保存数据，第二，不能及时(相对)响应。然后，我们可以改进为以下方法 1234567var stream = fs.createReadStream(path);stream.on('data',function(data){ res.write(data);});stream.on('end',function(){ res.end();}) 这种方法，乍一看，好像解决了传统方法的问题，但是！对于本地文件，可读流是快速的，相比于网络传输的数据，可写流的慢速的，所以服务器端的缓冲器将会很快被填满，然后继续讲数据写入内存中，还是会出现传统方法的第一个问题。就此问题，我们可以采用下面的方法解决 12345678910111213var stream = fs.createReadStream(path);stream.on('data',function(data){ if(!res.write(data)){//无法将数据写入缓冲区 stream.pause();//暂停发送数据 }});// 缓冲器已经没数据了！stream.on('drain',function(){ stream.resume();//恢复})stream.on('end',function(){ res.end();}) 也就是说，发送方将缓冲区填满后，就停止发送数据了，然后接收方将缓冲区数据完全读取走后，发送方恢复发送数据最后，stream.pipe()就是基于这种方法实现的，所以我们可以直接使用管道流 12//可读流结束发送数据后，可写流写完数据后自动结束关闭fs.createReadStream(path).pipe(res); 可以将数据流想象成水流，管道流就是一根水管，一端进水，另一端出水，也就是一端为可读数据流，另一端为可写数据流，而缓冲区就是水管的容量。github上的文件下载就是使用管道流实现的吧？     下载github地址 ",
            "path": "/2016/05/28/node-express-jade实现HTTP文件浏览器/"
        },
        {
            "title": "解决外网访问nodejs服务器（nginx反向代理）",
            "date": "2016-05-25",
            "content": " 前言之前说了我做的在线实时画板与你画我猜游戏，但是把程序放到服务器node运行后，却发现内网正常访问，外网却不能访问。于是搜索查找，得到解决方法，做此记录。 解决下载nginxnginx大致相当于一个转发器，通过url进行转发到正确处理的端口。 配置nginxconf/nginx.conf 添加如下 include myconf/*.conf; # 将myconf文件夹中*.conf 内容包含 在conf/myconf 中添加如下文件conf4000.conf123456789101112131415161718upstream web4000 { server localhost:4000;} server { listen 80; #监听的端口 server_name paintgame.moyuyc.xyz; #匹配的域名或者ip  location / { proxy_pass http://web4000; #转发到哪里？ proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; # 支持websocket proxy_set_header Connection \"upgrade\"; # 支持websocket }} 最后运行nginx即可，当然同时也需要运行node服务器关于websocket与upgrade 参看这里 其他问题 用了nginx后，打开[paint.moyuyc.xyz](http://paint.moyuyc.xyz/) 特别慢，[paintgame.moyuyc.xyz](http://paintgame.moyuyc.xyz/) 却挺正常的， 而且基于websocket 基于tcp长连接，经常会自己断开连接.  ",
            "path": "/2016/05/25/解决外网访问nodejs服务器（nginx反向代理）/"
        },
        {
            "title": "基于socket.io实现的简易你画我猜",
            "date": "2016-05-22",
            "content": " 前言一直都想好好的学习运用node，一直都不知道要做什么东西，最近Java Web老师要求做个前端的应用，既然是前端应用，那肯定得是单页应用了，而且node很适用于高并发的实时应用，所以便选择node以及基于node的socket.io 演示地址 实时画板+聊天室DemoGitHub  你画我猜+聊天室DemoGitHub  解释关于Socket.IO Socket.IO 是基于node实现的套接字前端后端数据交互的库，通过它的封装，使用者可以很方便的开发，而且支持websocket/ajax 长轮询等方法，兼容低版本浏览器。  基本使用如下：服务器端1234567891011var httpd = require('http').createServer(handler);var io = require('socket.io').listen(httpd);function handler(req,res) { }io.sockets.on('connection',function(socket){ //新的客户端连接 socket.on('login',(name,age)=>{ socket.emit('message',name+','+age);//触发客户端message事件 })}); 客户端引入js文件1<script src=\"socket.io/socket.io.js'></script> 进行交互12345var socket = io.connect(); //触发服务器端connection事件socket.emit('login','moyu',20); //触发服务器端login事件socket.on('message',function(msg){ alert(msg);}) 关于排行榜利用了js的匿名立即执行函数进行模块化包装123456789101112131415161718192021222324252627282930313233343536373839404142434445var tops = (function () { /* * _tops : 存放所有id,按照回答正确数倒序排列 * idmap : 一个hash map结构，key为id，value为名字与回答正确数 * n : 前n个，在toJSON调用 */ var _tops = [],idmap={},n=10; return { set : function (id,name,v) { if(this.isExists(id))//如果id已经存在则删除，防止出现重复id this.remove(id); // 找到按照v从大到小所对应的位置 var i = _tops.findIndex(x=>{return idmap[x].v<v;}); i= i===-1 ? _tops.length : i; // id在i+1位置插入至_tops _tops.splice(i,0,id); idmap[id] = {name:name,v:v}; }, isExists : function (id) { return idmap[id]!=null; }, remove : function (id) { var i = _tops.indexOf(id); if(i!==-1) { _tops.splice(i, 1); delete idmap[id]; return true; } return false; }, get:function (id) { return idmap[id]; }, toJSON:function () { // JSON.stringify方法会隐式调用该方法  var arr = []; _tops.every((x,i)=>{ if(i>=n) return false; arr.push({id:x,v:idmap[x].v,name:idmap[x].name}); return true; }); return arr; } }}()); 关于Bootstrap栅格12345678910111213141516171819202122232425262728293031323334353637383940.container{ margin-right: auto; margin-left: auto; //防止最外层的.row元素左右扩展15px padding-left: 15px; padding-right: 15px;}.col-3{ width: 30%;}.col-4{ width: 40%;}.col-9{ width: 90%;}/.../.row{ /* 向外左右延伸15px */ margin-right: -15px; margin-left: -15px;}/* 防止子元素为float,父元素的高度为0 */.row:before,.row:after { content: \" \"; display: table;}.row:after { clear: both;}.col-1, .col-2, .col-3, .col-4, .col-5, .col-6, .col-7, .col-8, .col-9{ padding-left: 15px; padding-right: 15px; float:left;} HTML结构1234567891011121314151617<main class='container'> <div class='row'> <div class='col-8'> <div class='row'> <div class='col-6'> <p>col-6</p> </div> <div class='col-4'> <div>col-4</div> </div> </div> </div> <div class='col-2'> <div>col-2</div> </div> </div></main> 关于一栏（多栏）宽度固定，一栏自适应 圣杯布局 双飞翼  感受…做单页应用真的需要挺大的心脏，而且需要较好的整体的架构，好在socket.io对websocket封装的不错，变成了面向消息的方式，代码结构相对更加清晰了些。…不敢想象用Java做这种实时单页应用后端会有多么的「拗口」最后推荐一个实时的更加优秀的游戏，slithe ",
            "path": "/2016/05/22/基于socket-io实现的简易你画我猜/"
        },
        {
            "title": "「项目拾遗」几个计算机图形学的前端程序",
            "date": "2016-05-10",
            "content": " 前言这是一篇不太正规的「计算机图形学论文」，其实论文谈不上，因为根本上不到研究的层次，就是自己瞎捣鼓。主要介绍了几个与图形学相关的程序，皆采用前端技术实现，点击即可查看。  简单的绘图程序 三次贝赛尔曲线应用-绘制平面动态花瓣 动态绘制三次贝赛尔曲线 三维几何体的基本变换与组合变换应用   主要内容简单的绘图程序介绍主要运用HTML5 canvas API与相关图形学知识实现的绘图程序（还包括部分图像处理功能，不介绍）。能够选择图形类型（Pen/Line/Circle）,画笔颜色（随机生成）,画笔宽度, 图形对象拖拽移动，图形种子填充算法。 演示图片 代码解释Shape.js ： 主要包含一些图形类 点类代码 1234567891011121314151617181920212223Point: function (x, y) { this.x = x; this.y = y; this.distance = function (p) { p = p?p:new Shape.Point(0,0); return Math.sqrt(Math.pow(p.x-this.x,2)+Math.pow(p.y-this.y,2)); }; this.move = function(offsetX,offsetY){ this.x+=offsetX;this.y+=offsetY; }; this.draw = function (paint, color, linewidth) { this.color = color?color:this.color; this.linewidth = linewidth?linewidth:this.linewidth; paint.strokeStyle = this.color ? this.color : 'black'; paint.lineWidth = this.linewidth!=null ? this.linewidth : 1; paint.beginPath(); paint.moveTo(this.x, this.y); paint.lineTo(this.x + 1, this.y + 1); paint.stroke(); paint.save(); return this; }} 线段类代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132Line: function (p1, p2) { this.sp = p1; this.ep = p2; //this.color;this.linewidth; this.move = function(offsetX,offsetY){ this.sp.x+=offsetX;this.sp.y+=offsetY; this.ep.x+=offsetX;this.ep.y+=offsetY; }; // 不足：未考虑线宽，用户较难选中 this.isIn = function (point) { var x = point.x, y = point.y; if((y-this.sp.y)*(x-this.ep.x)==(y-this.ep.y)*(x-this.sp.x)) return true; return false; }; // 中点划线法 this.draw = function (paint, color, linewidth) { this.color = color?color:this.color; this.linewidth = linewidth!=null?linewidth:this.linewidth; color = this.color; linewidth = this.linewidth; var ep = this.ep, sp = this.sp, dX = ep.x - sp.x, dY = ep.y - sp.y, a = sp.y - ep.y, b = ep.x - sp.x; if (Math.abs(dX) >= Math.abs(dY)) { if (dX >= 0 && dY >= 0) { var d = b + 2 * a, d1 = 2 * a, d2 = 2 * (a + b); new Shape.Point(sp.x, sp.y).draw(paint, color, linewidth); for (var x = sp.x + 1, y = sp.y; x < ep.x; x++) { if (d >= 0) d = d + d1; else { y++; d = d + d2; } new Shape.Point(x, y).draw(paint, color, linewidth); } } else if (dX >= 0 && dY <= 0) { var d = -b + a << 1, d1 = (a - b) << 1, d2 = a << 1; new Shape.Point(sp.x, sp.y).draw(paint, color, linewidth); for (var x = sp.x + 1, y = sp.y; x < ep.x; x++) { if (d >= 0) { y--; d = d + d1; } else d = d + d2; new Shape.Point(x, y).draw(paint, color, linewidth); } } else if (dX <= 0 && dY <= 0) { var d = -b - 2 * a, d1 = -2 * a, d2 = -2 * (a + b); new Shape.Point(sp.x, sp.y).draw(paint, color, linewidth); for (var x = sp.x - 1, y = sp.y; x > ep.x; x--) { if (d >= 0) d = d + d1; else { y--; d = d + d2; } new Shape.Point(x, y).draw(paint, color, linewidth); } } else { var d = b - 2 * a, d1 = 2 * (b - a), d2 = -2 * a; new Shape.Point(sp.x, sp.y).draw(paint, color, linewidth); for (var x = sp.x - 1, y = sp.y; x > ep.x; x--) { if (d >= 0) { y++; d = d + d1; } else d = d + d2; new Shape.Point(x, y).draw(paint, color, linewidth); } } } else { if (dX >= 0 && dY >= 0) { var d = a + 2 * b, d1 = 2 * (a + b), d2 = 2 * b; new Shape.Point(sp.x, sp.y).draw(paint, color, linewidth); for (var x = sp.x, y = sp.y + 1; y < ep.y; y++) { if (d >= 0) { x++; d = d + d1; } else { d = d + d2; } new Shape.Point(x, y).draw(paint, color, linewidth); } } else if (dX >= 0 && dY <= 0) { var d = a - 2 * b, d1 = -2 * b, d2 = 2 * (a - b); new Shape.Point(sp.x, sp.y).draw(paint, color, linewidth); for (var x = sp.x, y = sp.y - 1; y > ep.y; y--) { if (d >= 0) d = d + d1; else { x++; d = d + d2; } new Shape.Point(x, y).draw(paint, color, linewidth); } } else if (dX <= 0 && dY <= 0) { var d = -a - 2 * b, d1 = -2 * (a + b), d2 = -2 * b; new Shape.Point(sp.x, sp.y).draw(paint, color, linewidth); for (var x = sp.x, y = sp.y - 1; y > ep.y; y--) { if (d >= 0) { x--; d = d + d1; } else d = d + d2; new Shape.Point(x, y).draw(paint, color, linewidth); } } else { var d = -a + 2 * b, d1 = 2 * b, d2 = 2 * (b - a); new Shape.Point(sp.x, sp.y).draw(paint, color, linewidth); for (var x = sp.x, y = sp.y + 1; y < ep.y; y++) { if (d >= 0) d = d + d1; else { x--; d = d + d2; } new Shape.Point(x, y).draw(paint, color, linewidth); } } } return this; }} 圆类代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100Circle: function (cp, r) { this.cp = cp; this.r = r; this.move = function(offsetX,offsetY){ this.cp.x+=offsetX;this.cp.y+=offsetY; }; //this.color;this.linewidth; this.isIn = function (point) { var x = point.x, y = point.y; return (x-this.cp.x)*(x-this.cp.x)+(y-this.cp.y)*(y-this.cp.y)<=this.r*this.r; }; // 八分法画圆 this.draw = function (paint, color, linewidth) { this.color = color?color:this.color; this.linewidth = linewidth?linewidth:this.linewidth; color = this.color; linewidth = this.linewidth; //console.log(color); var r = this.r, cp = this.cp, d = 1 - r, p = new Shape.Point(0, r); while (p.x <= p.y) { new Shape.Point(cp.x + p.x, cp.y + p.y).draw(paint, color, linewidth); new Shape.Point(cp.x + p.x, cp.y - p.y).draw(paint, color, linewidth); new Shape.Point(cp.x - p.x, cp.y + p.y).draw(paint, color, linewidth); new Shape.Point(cp.x - p.x, cp.y - p.y).draw(paint, color, linewidth); new Shape.Point(cp.x + p.y, cp.y + p.x).draw(paint, color, linewidth); new Shape.Point(cp.x + p.y, cp.y - p.x).draw(paint, color, linewidth); new Shape.Point(cp.x - p.y, cp.y + p.x).draw(paint, color, linewidth); new Shape.Point(cp.x - p.y, cp.y - p.x).draw(paint, color, linewidth); p.x++; if (d < 0) d = d + 2 * p.x + 1; else { p.y--; d = d + 2 * p.x - 2 * p.y + 1; } } return this; }; //种子填充算法 深度优先搜索，基于栈，isam表示是否含动画填充效果 this.dfsFill = function (paint,p,color,isam) { isam = isam || false; var stack = [p],hashmap = {},container=[]; while (stack.length !== 0){ p = stack.pop(); if(isam) container.push(p); else p.draw(paint,color); [new Shape.Point(p.x,p.y-1), new Shape.Point(p.x-1,p.y), new Shape.Point(p.x,p.y+1), new Shape.Point(p.x+1,p.y)] .forEach(ele=>{ if(this.isIn(ele) && !hashmap[ele]) { stack.push(ele); hashmap[ele] = hashmap[ele]+1 || 0; } }); } console.log(hashmap); if(isam) { var animate = requestAnimationFrame; animate(function () { if (!container.length) return; container.shift().draw(paint, color);container.shift().draw(paint, color); container.shift().draw(paint, color);container.shift().draw(paint, color); container.shift().draw(paint, color);container.shift().draw(paint, color); container.shift().draw(paint, color);container.shift().draw(paint, color); animate(arguments.callee); }) } }; //种子填充算法 广度优先搜索，基于队列。 this.bfsFill = function (paint,p,color,isam) { isam = isam || false; var queue = [p],hashmap = {},container=[]; while (queue.length !== 0){ p = queue.shift(); if(isam) container.push(p); else p.draw(paint,color); [new Shape.Point(p.x,p.y-1), new Shape.Point(p.x-1,p.y), new Shape.Point(p.x,p.y+1), new Shape.Point(p.x+1,p.y)] .forEach(ele=>{ if(this.isIn(ele) && !hashmap[ele]) { queue.push(ele); hashmap[ele] = hashmap[ele]+1 || 0; } }); } console.log(hashmap); if(isam) { var animate = requestAnimationFrame; animate(function () { if (!container.length) return; container.shift().draw(paint, color);container.shift().draw(paint, color); container.shift().draw(paint, color);container.shift().draw(paint, color); container.shift().draw(paint, color);container.shift().draw(paint, color); container.shift().draw(paint, color);container.shift().draw(paint, color); animate(arguments.callee); }) } }} 路径类代码 123456789101112131415161718192021222324252627282930313233343536Path: function (points) { this.ps = points; this.move = function(offsetX,offsetY){ for(var i = 0;i<this.ps.length;i++){ this.ps[i].x+=offsetX; this.ps[i].y+=offsetY; } }; this.isIn = function (point) { var p = this.ps[0]; for(var i=1;i<this.ps.length;i++){ if(new Shape.Line(p,this.ps[i]).isIn(point)) return true; p = this.ps[i]; } return false; }; // 调用canvas提供的api this.draw = function (paint,color,linewidth) { this.color = color?color:this.color; this.linewidth = linewidth?linewidth:this.linewidth; color = this.color; linewidth = this.linewidth; //console.log(color); var arr = this.ps; if(arr.length==0) return; paint.beginPath(); paint.strokeStyle = color ? color : 'black'; paint.lineWidth = linewidth ? linewidth : 1; paint.moveTo(arr[0].x,arr[0].y); for(var i =1;i<arr.length;i++){ paint.lineTo(arr[i].x,arr[i].y); } paint.stroke(); return this; }} canvas.js: 包含其他一些对事件的绑定或者对控件的控制等代码 选中图形进行拖动函数 12345678910111213141516171819202122232425dragMoveHandle = function () { var f1 = function(e){ var x = e.offsetX, y = e.offsetY; var v = Tool.getInFirstShape(new Shape.Point(x,y)); if(v){ var f2 = function (e2) { if(e2.buttons==1){ var offsetx = e2.offsetX-x, offsety = e2.offsetY-y; x=e2.offsetX; y = e2.offsetY; v.move(offsetx,offsety); Tool.refresh(); } },f3 = function (e3) { var offsetx = e3.offsetX-x, offsety = e3.offsetY-y; v.move(offsetx,offsety); Tool.refresh(); // e3.stopPropagation(); $(this).off('mousemove',f2).off('mouseup',f3); }; $(paint.canvas).on('mousemove',f2).on('mouseup',f3).off('mousedown',f1); }else $('[role=opType-item]').removeClass('active');}$(paint.canvas).on('mousedown',f1)} 关于Tool对象 1234567891011121314151617181920212223242526Tool = { getInFirstShape : function(p){ var f = function(d){ for(var i =0;i< d.length;i++){ if(d[i].isIn(p))//点p是否在d[i]图形对象中？ return d[i]; } return false; }; var r; for(var d in paint.data) //paint.data 表示存在于画布中的所有图形对象 if((r=f(paint.data[d]))!=false) return r; }, // 重新绘制 refresh : function () { paint.clearRect(0,0,paint.canvas.width,paint.canvas.height); for(var i =0;i<paint.data.Paths.length;i++) paint.data.Paths[i].draw(paint); for(var i =0;i<paint.data.Lines.length;i++) paint.data.Lines[i].draw(paint); for(var i =0;i<paint.data.Circles.length;i++) paint.data.Circles[i].draw(paint); }} 不足之处 对于Line的isIn方法，未考虑到线宽的因素，用户很难准确选中线段 对于拖动图形的事件处理逻辑较复杂。 对于图形类中未使用到js中的原型与原型继承，降低了代码复用度。  三次贝赛尔曲线应用-绘制平面动态花瓣介绍主要运用HTML5 canvas API与相关图形学知识实现的平面动态花瓣绘制。 演示图片 代码解释 核心代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function Flower(c,petals,size,x,y,rotate){ this.c = c || [255,255,255]; this.petals = petals || 4; this.size = size || 5; this.x = x || 0; this.y = y || 0; this.rotate = rotate || 0;}Flower.prototype.draw = function(){ var _rad = this.size,_num_pts=this.petals,_x=this.x,_y=this.y,c=this.c; ctx.save(); ctx.shadowBlur = 30; //阴影程度 ctx.lineWidth = 1; ctx.shadowColor = utils.rgba(c[0],c[1],c[2],1); //阴影颜色 ctx.fillStyle = utils.rgba(c[0],c[1],c[2],.6); //填充颜色 c2 = c.map((x)=>Math.floor(x/1.6)); //lambda表达式写法 ctx.strokeStyle = utils.rgba(c2[0],c2[1],c2[2],1); //边框颜色 var pts = []; var _a = this.rotate+(tick*1); for (var i = 0 ; i <= _num_pts ; i++){//增量法提高效率 pts.push({x:utils.P2L(_rad, _a).x,y:utils.P2L(_rad, _a).y}); //P2L将极坐标转换为平面坐标 _a += (360/_num_pts); } for (var i = 1 ; i<= _num_pts; i+=2){ idx= i%_num_pts; ctx.beginPath();//开始绘制 ctx.moveTo(_x,_y);//起点为(_x,_y) ctx.bezierCurveTo(_x+pts[i-1].x,_y+pts[i-1].y,_x+pts[idx+1].x,_y+pts[idx+1].y,_x,_y);//绘制贝塞尔曲线 ctx.stroke();//闭合图形边框 ctx.fill();//填充图形 } ctx.restore();}HTMLCanvasElement.prototype.magicBg = function(){ var ctx = this.getContext('2d'); if(!this.grd){ //实现从画布中心往外呈圆形扩散，渐变。 this.grd=ctx.createRadialGradient(this.width/2,this.height/2,0,this.width/2,this.height/2,Math.min(this.width,this.height)/1.2); this.grd.addColorStop(0,\"rgba(255,255,255,.25)\"); this.grd.addColorStop(1,this.utils.rgba(200+this.utils.randomInt(56),200+this.utils.randomInt(56),200+this.utils.randomInt(56),.65)); } ctx.save(); ctx.clearRect(0,0,this.width,this.height); ctx.fillStyle = this.grd; ctx.fillRect(0,0,this.width,this.height); ctx.restore();}  Flower对象解释      参数 说明 默认 类型     c 花瓣的颜色 [255,255,255] Array   petals 花瓣个数 4 Number   size 半径大小 5 Number   x 中心 x 坐标 0 Number   y 中心 y 坐标 0 Number   rotate 绕中心旋转角度 0 Number(单位：度)     Flower.draw 方法解释     变量 说明     _rad radix，对应size   _num_pts 对应petals   _x 对应x   _y 对应y   c 对应c     关于贝塞尔曲线，参考资料   图：三次贝塞尔曲线动态绘制效果 图：花瓣与其贝塞尔曲线控制点  怎么使用？   <script src='drawflower.js'></script> canvas.drawFlower(option);  123456789101112//default option{ animate:false, rotate:90, randomSize:true, randomColor:true, randomPetals: true, pos:{ x:this.width/2, y:this.height/2 }} or1234567891011121314{ animate:true, rotate:-20, randomSize:false, size:10, randomColor:false, color:[100,100,100], randomPetals: false, petals:6, pos:{ x:0, y:0 }} 动态绘制三次贝赛尔曲线介绍应用canvas API, 事件绑定, 达到动态绘制三次贝赛尔曲线效果。 演示图片 代码解释自己定义的Pos Rect Circle 类123456789101112131415161718192021222324252627function Pos(x,y){this.x=x;this.y=y;}function Circle(p,r){this.p=p;this.r=r;}Circle.prototype.draw = function(sty){ ctx.save(); ctx.strokeStyle=sty||'blue'; ctx.beginPath(); ctx.arc(this.p.x, this.p.y, this.r, 0, Math.PI * 2, true); ctx.stroke(); ctx.restore();}// p is in Circle?Circle.prototype.around=function(p){ return (p.x-this.p.x)*(p.x-this.p.x)+ (p.y-this.p.y)*(p.y-this.p.y)<=this.r*this.r;}function Rect(p,w,h){this.p=p;this.w=w;this.h=h;};Rect.prototype.draw = function (style) { ctx.save(); ctx.strokeStyle=style||'blue'; var v = this.w>>> 1,t = this.h>>>1; ctx.strokeRect(this.p.x-v, this.p.y-t,this.w,this.h); ctx.restore();}// p is in Rect?Rect.prototype.around = function (p) { var v = this.w>>> 1,t = this.h>>>1; return p.x>=this.p.x-v && p.x<=this.p.x+v && p.y>=this.p.y-t && p.y<=this.p.y+t;} 初始化12345var midP = new Pos(window.innerWidth>>>1,window.innerHeight>>>1), sP = new Circle(new Pos(midP.x-100,midP.y-100),4), cP1= new Rect(new Pos(midP.x-80,midP.y+10),8,8), cP2= new Rect(new Pos(midP.x+80,midP.y+20),8,8), eP = new Circle(new Pos(midP.x+100,midP.y+100),4); 绘制三次贝塞尔曲线1234567891011function drawBezier(ps){ ctx.save(); ctx.beginPath(); ctx.moveTo(ps[0].x,ps[0].y); ctx.bezierCurveTo(ps[1].x,ps[1].y,ps[2].x,ps[2].y,ps[3].x,ps[3].y); ctx.stroke(); // 自己实现的绘制虚线方法 ctx.dashedLineTo(ps[0].x,ps[0].y,ps[1].x,ps[1].y); ctx.dashedLineTo(ps[3].x,ps[3].y,ps[2].x,ps[2].y); ctx.restore();} ctx.dashedLineTo方法123456789101112131415161718192021222324252627CanvasRenderingContext2D.prototype.dashedLineTo = function (fromX, fromY, toX, toY, pattern) { // default interval distance -> 5px if (typeof pattern === \"undefined\") { pattern = 5; } // calculate the delta x and delta y var dx = (toX - fromX); var dy = (toY - fromY); var distance = Math.floor(Math.sqrt(dx*dx + dy*dy)); var dashlineInteveral = (pattern <= 0) ? distance : (distance/pattern); var deltay = (dy/distance) * pattern; var deltax = (dx/distance) * pattern; // draw dash line this.beginPath(); var f = 1; while (dashlineInteveral-->0){ if(f) { this.lineTo(fromX, fromY); } else { this.moveTo(fromX, fromY); } fromX += deltax; fromY += deltay; // 增量法 f = 1-f; } this.stroke();}; 鼠标事件绑定处理1234567891011121314151617181920212223242526canvas.addEventListener('mousedown', function (e1) { var p1 = new Pos(e1.offsetX,e1.offsetY),c; [sP,cP1,cP2,eP].every(ele=>{ if(ele.around(p1)){ c = ele; return false; } return true; }); if(c){ c.draw('red'); canvas.addEventListener('mousemove',function (e) { this.mousemove = arguments.callee; if(e.buttons===1){// left mouse pressed down var pos = new Pos(e.offsetX,e.offsetY); c.p = pos; rePaint([c]); c.draw('red'); } }); }})canvas.addEventListener('mouseup', function (e) { this.removeEventListener('mousemove',this.mousemove); rePaint();}); rePaint(ignores) 重新绘制函数12345678910111213141516171819// ignores 为跳过不重绘的点(Circle/Rect)function rePaint(ignores){ ctx.save(); ctx.clearRect(0,0,canvas.width,canvas.height); if(ignores==null){ cP1.draw(); cP2.draw(); sP.draw(); eP.draw(); } else { [sP,cP1,cP2,eP].forEach(el=>{ if(ignores.indexOf(el)==-1) el.draw(); }); } drawBezier([sP.p,cP1.p,cP2.p,eP.p]); ctx.restore();} 三维几何体的基本变换与组合变换应用介绍运用前端WebGL框架threejs，结合相关矩阵变换知识完成。 演示图片 代码解释三维基本变换组合变换文档参考下载  基本变换之平移变换  12345var matD = new THREE.Matrix4();//thressjs 封装的API，产生平移变换矩阵matD.makeTranslation(myctls[0].x,myctls[0].y,myctls[0].z);// mesh为几何体，将其矩阵与平移变换矩阵相乘mesh.matrix.multiply(matD);  基本变换之比例变换  12matD.makeScale(myctls[1].x,myctls[1].y,myctls[1].z);mesh.matrix.multiply(matD);  组合变换之关于任意向量旋转 123var v3 = myctls[2].vector.toVector3();matD.makeRotationAxis(v3.normalize(),myctls[2].degree/360*Math.PI)mesh.matrix.multiply(matD);  …   总结 学习巩固了相关图形学的知识。 学习了相关前端技术对图形的处理方法。 对于WebGL简单入门了，以后可以往更酷炫的3D效果靠近。  ",
            "path": "/2016/05/10/「项目拾遗」几个计算机图形学的前端程序/"
        },
        {
            "title": "百度前端二面总结（已过）",
            "date": "2016-05-04",
            "content": " 前言昨天，进行了百度第二次前端面试，结果今天中午就通知我过了，准备本周五进行三面，百度的办事效率还挺高的哈。写这篇文章为了记录和总结一下，已经回顾自己的不足，以及展望下后面的计划。 开始前夕我听取了一面面试官的建议，花了一周时间捣鼓了一个静态博客，所以我就在简历上加上了我的博客地址，然后发了一份新的简历给二面面试官。二面面试官比一面面试官「活跃」些，互动也多了些。 视频开始中午二点，正式开始视频面试，出乎我意料之外的是，面试官居然也露出了庐山真面目。一开始面试官就吐英语了！听得我一愣一愣的（可能在文字聊天的时候我一直有发okok，让面试官误以为我英语不错），还好没听明白的地方，面试官会翻译。简单做了一下自我介绍后，面试官便进入了自己的节奏，说明这次面试主要是测试我的编码能力，需要共享我的电脑桌面，看我敲代码。当时内心还是有点慌的，「怎么跟网上的二面面经不太一样啊！」，于是便开始了出题编码环节。 第一题12345678910111213/* 用 javascript 语言,手工实现 repeat 函数.两个参数: 1.要重复的原始字符串 2.需要重复的次数 例如: repeat ('a', 3) => 'aaa' */function repeat (str, count) { // your code here} 恩恩，第一题不难，头脑中首先冒出两种方法1234567891011121314function repeat (str, count) { if(str != undefined && count!= undefined && count>0 && !isNaN(count)) { // 1 var s =''; for(var i=0;i<count;i++){ s+=str; } return s; //2 var arr = new Array(count + 1); return arr.join(str); }} 但是，面试官肯定要深问啊，要求我用递归来实现。当时比较紧张…,思路不是很清晰…,有点乱。开始是用下面的递归方法：12345678910function repeat(str ,count) { var s = ''; rep(str,count); return s; function rep(str,count) { if(count<=0) return; s+=str; arguments.callee(str,--count); }} 面试官还是不满意！让我改进，不用”全局变量” s，于是修改代码为下：12345678function repeat(str ,count) { return rep('',str,count); function rep(s,str,count) { if(count<=0) return str; s+=str; return arguments.callee(s,str,--count); }} 第二题123456789101112/* 使用 原生javacript 实现事件代理 例子: delegate ( containerElement, 'click', 'remove-item', onClick ) 会绑定一个事件代理到 containerElement 这个元素, 即是说, 所有在 containerElement 这个容器下的所有 .remove-item 在click事件出现时都会触发 onClick 这个回调 */function delegate(parentElem, eventType, className, callback) {} 第二题也是比较常规的事件委托题目，想了一会儿，还好是想出来了。123456789101112131415function delegate(parentElem, eventType, className, callback) { if(parentElem.attachEvent) parentElem.attachEvent('on'+eventType,function (e) { if(e.srcElement.classList.contains(className)){ callback(e); } }); else{ parentElem.addEventListener(eventType,function (e) { if(e.target.classList.contains(className)){ callback(e); } }); }} 写完后，面试官继续问：有没有方法可以让事件响应更快速点。额，想了一分钟吧，面试官看我没声音，就直接到第三题了。 其实，后面仔细想了下，觉得可以将`addEventListener`方法中的第三个参数设置为`true`，也就是按照事件捕获方式响应， DOM事件流首先要捕获事件（由父结点到子节点），然后是事件冒泡（由子节点到父结点）。 `addEventListener`方法第三个参数默认为`false`，表示事件冒泡处理事件，所以我觉得设置为`true`，应该能够更快的响应事件。 第三题开放题，考察我学习新知识的能力和方法，让我做出一个跟React中第三个Demo一样的效果（使用React）。http://facebook.github.io/react/…当时我已经是比较懵逼了，就查看源码呗，看下官网上实现这个Demo的源码在哪，然后导入库文件，复制代码试试看咯。但是当时突然就网络不好了，github上不去了，结果面试官还主动帮我下库文件，600多KB，结果发给我的数据居然是1KB/s，所以最后这道题不了了之。时间差不多了，就结束了。 总结最后我才知道一共有四道题目（恩，第四题也不知道是个什么东西）。从腾讯一面被刷到百度的二面通过，等待三面，真是验证了一句话「机会是留给有准备的人的。」还有，紧张只会给自己添乱子！最后我希望三面也能顺风顺水吧。如果拿到实习offer后，希望在实习的时候也能拿出以往的「折腾、捣鼓」精神，能够顺利转正。 ",
            "path": "/2016/05/04/百度前端二面总结（已过）/"
        },
        {
            "title": "「转」为什么v8 javascript引擎这么快",
            "date": "2016-05-02",
            "content": " 说明为什么转载？  这篇文章内容比较丰富，涉及的知识点也比较广泛，有编译原理，数据结构，汇编…需要对计算机整体有个比较好的认识与把控，才能理解深刻。  遂转该文章，以便后续的学习与理解。 前言 Google研发的V8 JavaScript引擎性能优异。我们请熟悉内部程序实现的作者依源代码来看看V8是如何加速的。 作者：Community Engine公司研发部研发工程师Hajime Morita Google的Chrome中的V8 JavaScript引擎，由于性能良好吸引了相当的注目。它是Google特别为了Chrome可以高速运行网页应用(WebApp)而开发的。Chrome利用Apple领导的WebKit研发计划作为渲染引擎（Rendering engine）。 WebKit也被用在Safari浏览器中。WebKit的标准配备有称为JavaScriptCore的JavaScript引擎，但Chrome则以V8取代之。 V8开发小组是一群程序语言专家。核心工程师Lars Bak之前研发了HotSpot，这是用在Sun Microsystems公司开发的Java虚拟机器（VM）之加速技术。他也在美国的Animorphic Systems公司（于1997年被Sun Microsystems所并购）研发了称为Strongtalk的实验Smalltalk系统。V8充分发挥了研发HotSpot和Strongtalk时所获得的知识。 图1 开发自己的JavaScript引擎  Apple的Safari和Google的Chrome使用相同的渲染引擎。配有JavaScriptCore的WebKit渲染引擎在JavaScript引擎中是标准配备，但在Chrome却被V8取代了.  高速引擎的需求 Google研发小组在2006年开始研发V8，部分的原因是Google对既有JavaScript引擎的执行速度不满意。我认为当时JavaScript引擎很慢是有两个原因的：开发的历史背景，以及JavaScript语言的复杂性。  JavaScript存在至少10年了。在1995年，它出现在网景(Netscape Communications)公司所研发的网页浏览器Netscape Navigator 2.0中。然而有段时间人们对于性能的要求不高，因为它只用在网页上少数的动画、交互操作或其它类似的动作上。(最明确的是为了减少网络传输，以提高效率和改善交互性！)浏览器的显示速度视网络传输速度以及渲染引擎（rendering engine）解析HTML、风格样式表（cascading style sheets, CSS）及其他代码的速度而定。浏览器的开发工作优先提升渲染引擎的速度，而JavaScript的处理速度不是太重要。同时出现的Java有相当大的进步，它被做得愈来愈快，以便和C++竞争。  然而，在过去几年，JavaScript突然受到广泛使用。原因是之前被当成桌面应用的软件（其中包括Office套件等），现已成为可以在浏览器中执行的软件。  Google本身就推出了好几款JavaScript网络应用，其中包括它的Gmail电子邮件服务、Google Maps地图数据服务、以及Google Docs office套件。  这些应用表现出的速度不仅受到服务器、网络、渲染引擎以及其他诸多因素的影响，同时也受到JavaScript本身执行速度的影响。然而既有的JavaScript引擎无法满足新的需求，而性能不佳一直是网络应用开发者最关心的。 语言本身的问题 JavaScript语言的规范现在性能压力巨大。例如，这在当它判定变量类型时就相当显而易见。如C++和Java等主流语言采用静态类型(static typing)。当代码编译时，就可宣告变量类型。由于不需要在执行期间检查数据类型，因此静态类型占有性能上的优势。  在例如C++和Java等一般处理系统中，fields和methods等的内容是以数组储存，以1:1位移（offset）对应fields和methods等的名称（图2）。个别变量和methods等储存的位置，是针对各个类定义的。在C++和Java等语言中，已事先知道所存取的变量（类）类型，所以语言解释系统(Interpreting system)只要利用数组和位移来存取field和method等。位移使它只要几个机器语言指令，就可以存取field、找出field或执行其他任务。 图2 JavaScript和C++、Java的不同 C++、Java及其他处理系统将fields和methods等，以它们的名称以1:1对应数组内的位移值储存在数组中。会事先知道要存取的变量类型（类），因此可以只用数组和位移就可以存取fields和methods等。然而在JavaScript，个别的对象都有自己属性和方法等的表格。每一次程序存取属性或是呼叫方法时，都必须检查对象的类型并执行适当的处理。- Field：属对象的变量。C++中称为成员变量。- Method：属对象的处理类型。C++中称为成员函式。- Property属性：JavaScript属性是对象自己拥有的变量。在JavaScript中，属性中不只可以是标准的值，也可以是methods。- Hash table哈希表：一种数据结构会传回与特定关键相关之对应值。它有一个内部数组，使用键值(key)所产生之Hash值作为数组中特定位置清单值的位移。如果刚好在相同的位置上产生不同关键之Hash值时，清单位置会储存多个值，这意味着在传回任何值之前必须先检查Hash值是否符合。 而另外一方面，JavaScript则是利用动态类型(dynamic typing)。 JavaScript变量没有类型，而所指定对象的类型在第一次执行时（换言之，动态地）就已判定了。每次在JavaScript中存取属性(property)，或是寻求方法等，必须检查对象的类型，并照着进行处理。 许多JavaScript引擎都使用哈希表（hash table）来存取属性和寻找方法等。换言之，每次存取属性或是寻找方法时，就会使用字符串作为寻找对象哈希表的键(key)（图3）。 图3 属性存取时的内部JavaScript处理  使用对象x哈希表的字符串「foo」作为搜寻「foo」内容的关键字。   搜寻哈希表是一个连续动作，包含从散列(hashing)值中判定数组内位置，然后查看该位置的键值（key）是否符相等。然后可以使用位移直接读取数据的数组比较起来，利用此方法存取较费时。  使用动态类型的其他语言，还有Smalltalk和Ruby等。这些语言基本上也是搜寻哈希表，但它们利用类来缩短搜寻时间。然而，JavaScript没有类。除了「Numbers」指示数字值、「Strings」为字符串以及其他少数几种类型外，其他对象都是「Object」型。程序员无法宣告类型（类），因此无法使用明确的类型来加速处理。  JavaScript的弹性允许在任何时间，在对象上新增或是删除属性和方法等（请参阅附录）。JavaScript语言非常动态，而业界的一般看法是动态语言比C++或Java等静态语言更难加速。尽管有困难，但V8利用好几项技术来达到加速的目的: JIT编译 (JIT Compile) 不用字节码(bytecode)生成机器语言 从性能的角度来看，V8具有4个主要特性。首先，它在执行时以称为及时（just-in-time, JIT）的编译方法，来产生机器语言。这是个普遍用来改善解释速度的方法，在Java和.NET等语言中也可以发现此方法。V8比Firefox中的SpiderMonkey JavaScript引擎，或Safari的JavaScriptCore等竞争引擎还要早的实践了这一技术。  V8 JIT编译器在产生机器语言时，不会产生中间码（图4）。例如，在Java编译器先将原始码转换成一个以虚拟中间语言（称为字节码，bytecode）表示的一类文件 (class file)。Java编译器和字节码编译器产生字节码，而非机器语言。Java VM按顺序地在执行中解释字节码。此执行模式称为字节码解释器(bytecode interpreter)。 Firefox的SpiderMonkey具有一个内部的字节码编译器和字节解释器，将JavaScript原始码转换成它自家特色的字节代码，以便执行。  图4 V8的JIT编译器直接输出机器语言  序语言系统先使用语法分析器将原始码转换成抽象语法树（abstract syntax tree, AST）。之前有几种方式来处理。字节码编译器将抽象语法树编译为中间代码，然后在编译器中执行。如Java JIT等混合模式将这中间代码的一部分编译成机器语言，以改善处理性能。Chrome不使用中间代码，JIT直接从抽象语法树来编译机器语言。也有抽象语法树解释器，直接解析抽象语法树。   事实上，Java VM目前使用一个以HotSpot为基础的JIT编译器。它扮演字节码解释器的角色，来解析代码，将常执行的代码区块转换成机器语言然后执行，这就是混合模式(hybrid model)。  字节码解释器、混合模式等等，具有制作简单且有绝佳可移植性的优点。只要是引擎可以编译的原始码，那么就可以在任何CPU架构上执行字节码，这正是为什么该技术被称为「虚拟机(VM)」的原因。即使在产生机器代码的混合模式中，可以借由编写字节码的解释器开始进行开发，然后实现机器语言生成器。通过使用简单的位元码，在机器代码产生时，要将输出最佳化就变得容易许多。  V8不是将原始程序转换成中间语言，而是将抽象语法直接产生机器语言并加以执行。没有虚拟机，且因为不需要中间表示式，程序处理会更早开始了。然而，另一方面，它也丧失了虚拟机的好处，例如透过字节码解释器和混合模式等，所带来的高可移植性(portability)和优化的简易性等。   垃圾回收管理Java标准特性的精妙实现 第二个关键的特性是，V8将垃圾回收管理（garbage collection, GC）实作为「精确的GC」。相反的，大部分的JavaScript引擎、Ruby及其他语言编译器都是使用保守的GC*(conservative GC)，因为保守的GC实作简单许多。虽然精确的GC更为复杂，但也有性能上的优点。Oracle(Sun)的Java VM就是使用精确GC。  Garbage collection（GC）垃圾回收管理：自动侦测被程序保留但已不再使用的存储器空间并释放。 保守(conservative) GC：没有分别严格管理指标器和数字值之存储器回收管理。此方法是如果它可以成为指标，那就以指标来看待它，即使它可能个数值。此方法防止对象被意外回收，但它也无法释出可能的存储器。   虽然精确GC本身就是高效率的，但以精确GC为基础的高级算法，如分代(Generational) GC、复制(copy) GC以及标记和精简处理（mark-and-compact processing）等在性能上有明显的改善。分代(Generational) GC藉由分开管理「年青分代(Young Generational)」对象（经常收集）和「旧分代(Old Generational)」对象（相对长寿的对象）而提升了GC效率。V8使用了分代(Generational)GC，在新分代(Generational)处理上使用轻度(light-load)复制GC，而在旧GC上使用标记和精简GC，因为它须在内存空间内移动对象。这很难在保守GC中执行。在对象的复制中，压缩（compaction）（在硬盘方面称为defrag）和类似动作时，对象的地址会改变，且基于这个原因，最普遍的方法是用「句柄」（handles）间接地引用地址。然而，V8不使用句柄(handles)，而是重写该对象引用的所有数据。不使用句柄(handles)会使实现更困难，但却能改善性能因为少了间接引用。Java VM HotSpot也使用相同的技术。 内嵌缓存(inline cache)JavaScript中不可用？ V8目前可以针对x86和ARM架构产生适合的机器语言。虽然没采用C++或Java中传统的优化方式，V8还是有动态语言与生俱来的速度。  其中一项良好范例是内嵌缓存（inline cache），这项技巧可以避免方法呼叫和属性存取时的哈希表搜寻。它可以立即缓存之前的搜寻结果，因此称为「内嵌」。人们知道此技术已有一段时间了，已经被应用在Smalltalk、Java和Ruby等语言中。  内嵌缓存假设对象都有类型之分，但在JavaScript语言中却没有。直到V8出现后，而这就是为什么以前的JavaScript引擎都没有内嵌缓存的原因。  为了突破此限制，V8在执行时就分析程序操作，并利用「隐藏类」（hidden classes）为对象指定暂时的类。有了隐藏类，即使是JavaScript也可以使用内嵌缓存。但是这些类是提升执行速度之技巧，不是语言规范的延伸。所以它们无法在JavaScript代码中引用。 隐藏类储存类型转换信息 隐藏类为没有类之分的JavaScript语言规范带来有趣的挑战，同时也是V8用来提升速度最独特的技巧。它们值得更深入的探究。  在V8中建立类有两个主要的理由，即（1）将属性名称相同的对象归类，及（2）识别属性名称不同的对象。前一类中的对象有完全相同的对象描述，而这可以加速属性存取。  在V8，符合归类条件的类会配置在各种JavaScript对象上。对象引用所配置的类（图5）。然而这些类只存在于V8作为方便之用，所以它们是「隐藏」的。 图5 V8对象有隐藏类的引用> 如果对象的描述是相同的，那么隐藏类也会相同。在此范例中，对象p和q都属于相同的隐藏类 我上面提到随时可以在JavaScript中新增或删除属性。然而当此事发生时会毁坏归类条件（归纳名称相同的属性）。V8借由建立属性变化所需的新类来解决。属性改变的对象透过一个称为「类型转换(class transition)」的程序纳入新级别中。 第二个目标－识别属性名称不同的对象－则是借由建立新类来达成。然而，如果每一次属性改变就建立一个新类的话，那就无法持续达到第一个目标了（归纳名称相同的属性）。图6 配置新类：类型转换  属性改变的对象会被归为新类。当对象p增加了新属性z时，对象p就会被归为新类。   V8将变换信息储存在类内，来解决此问题。考量图7，它说明了图6中所示的情形，当隐藏类Point有x和y属性时，新属性x就会新增至Point级的对象p中。当新属性z加到对象p时，V8会将「新增属性p，建立Point2类」的信息储存在Point级的内部表格中（图7，步骤1）。图7 在类中储存类变换信息当在对象p中加入新属性z时，V8会在Point类内的表格上记录「加入属性z，建立类Point2」（步骤1）。当同一Point类的对象q加入属性z时，V8会先搜寻Point类表。如果它发现了Point2类已加入属性z时，就会将对象q设定在Point2类（步骤2）。  当新属性z新增至也是Point级的对象q时，V8会先搜寻Point级的表格，并发现Point2级已加入属性z。在表格中找到类时，对象q就会被设定至该类（Point2），而不建立新类（图7，步骤2）。这就达到了归纳属性名称相同的对象之目的。  然而此方法，意味着与隐藏类对应的空对象会有庞大的转换表格。V8透过为各个建构函数建立隐藏类来处理。如果建构函数不同，就算对象的陈述(layout)完全相同，也会为它建立一个新的隐藏类。 内嵌缓存 其它的JavaScript引擎和V8不同，它们将对象属性储存在哈希表中，但V8则将它们储存在数组中。位移信息－指定个别属性在数组中的位置－是储存在隐藏类的哈希表中。同一隐藏类的对象具有相同的属性名称。如果知道对象类，那么就可以利用位移依数组操作存取属性。这比搜寻哈希表快许多。  然而，在JavaScript等动态语言中，很难事先知道对象类型。例如，图8的原始码为对象类型p和q呼叫lengthSquared()函数。对象类型p和q的属性不同，隐藏类也不同。因此无法判定lengthSquared()函数代码的参数（arguments）类型。  若要读取函数中的对象属性，必须先检查对象的隐藏类，并有搜寻类的哈希表，以找出该属性的位移。然后利用位移存取数组。尽管是在数组中存取属性，要先搜寻哈希表的需求就毁掉了使用数组的优点。  然而，从不同的观点来看，情况有所不同。在实际的程序中，依赖代码执行判断类型的情况并不多。例如，在图8的lengthSquared()函数甚至假设大部分通过成为参数的值，都是Point类对象，而一般而言这是正确的。 12345678910111213141516function lengthSquared(p) { return p.x* p.x+ p.y* p.y;}function LabeledLocation(name, x, y) { this.name= name; this.x= x; this.y= y;}var p= new Point(10, 20);var q= new LabeledLocation(\"hello\", 10, 20);var plen= lengthSquared(p);var qlen= lengthSquared(q); 图8 代码样本：JavaScript无法判断函数参数类型  在执行之前根本无法判断参数是Point型或是lengthSquared()函数的LabeledLocation型。   内嵌缓存是一项加速技术，此设计是为了利用程序中局部（local）类别的方法。若要程序化的属性存取，V8会产生一个指令串来搜寻隐藏类列表（图9）。此代码称为premonomorphic stub。此stub是为了在函数存取属性（图10）。Premonomorphic stub拥有两个信息：搜寻用的隐藏类，以及取自隐藏的位移。最后会产生新代码以缓存此信息（图11）。 123456Object* find_x_for_p_premorphic(Object* p) { Class* klass= p->get_class(); int offset = klass->lookup_offset(\"x\"); update_cache(klass, offset); return p->properties[offset];} 图9 在伪代码（pseudocode）中的premonomorphic stub 从隐藏类中取得属性位移。 图10 premonomorphic stub呼叫存取函数中的属性时会呼叫premonomorphic stub。 1234567Object* find_x_for_p_monomorphic(Object* p) { if (CACHED_KLASS == p->get_class()) { return p->properties[CACHED_OFFSET]; } else { return lookup_property_on_monomorphic(p, \"x\"); }} 图11伪代码的monomorphic stub 处理直接嵌入代码中的位移是用来存取属性的常数。  在搜寻表格之前，带有属性的对象之隐藏类会与缓存隐藏类比较。如果相符就不需要再搜寻，且可以使用缓存的位移来存取属性。如果隐藏类不相符，就透过隐藏类哈希表以一般方式判断位移。  新产生的代码被称为monomorphic stub。「内嵌」这个字的意思是查询隐藏类所需的位移，是以立即可用的形式嵌入在所产生的代码中。当第一次叫出monomorphic stub时，它会将功能从pre-monomorphic stub位址中所叫出的第一个位址重写成monomorphic stub位址（图12）。自此，使用高速的monomorphic stub，单靠类比较和数组存取就可以处理属性存取。 图 12 monomorphic stub呼叫  当呼叫monomorphic stub时，它会将功能从premonomorphic stub位址中叫出的第一个位址，重写成monomorphic stub位址。   如果只有一个具有属性的对象，monomorphic stub的效率就会很高。然而，如果类型愈多，缓存失误就会更频繁，进而降低monomorphic stub的效率。  当缓存失误时，V8藉由产生另一个称为megamorphic stub的代码来解决（图13）。与个别类对应的monomorphic stub都写在哈希表中，其在执行时搜寻和叫出stub。如果没有类型对应的monomorphic stub时，就会从类型哈希表中搜寻位移。 1234567891011Object* find_x_for_p_megamorphic(Object* p) { Class* klass= p->get_class(); //内嵌处理实际的搜寻 Stub* stub= klass->lookup_cached_stub(\"x\") if (NULL != stub) { return (*stub)(p); } else { return lookup_property_on_megamorphic(p, \"x\"); }} 图13伪代码中的Megamorphic stub处理与类型对应的monomorphic stub事先储存在哈希表中，并在执行时被搜寻和叫出。如果无法找到对应的monomorphic stub，就会在类型哈希表中搜寻位移。  当monomorphic stub发生缓存失误时，monomorphic stub会将功能从monomorphic stub位址叫出的第一个位址以megamorphic stub位址重写。在代码搜寻方面，megamorphic stub的性能比monomorphic stub低，但是megamorphic代码却比使用缓存更新、代码生成及其他辅助处理的premonomorphic stubs快许多。  涵盖多种类的内嵌缓存称为多型态内嵌缓存(polymorphic inline cache)。V8内嵌缓存系统被用来呼叫方法以及存取属性。 机器语言的特性 如以上所述，V8在设计时使用了例如内嵌缓存等，来达到动态语言中天生的速度。创建使用于内嵌缓存之stub的机器语言生成模块密切地与JIT编译器连结。  一些经常使用的方法也被写成机器语言以达到与内嵌拓展相同的效果，使它们成为「内在」的。V8原始码列出了内在转换的候选名单。  V8所含的shell程序可以用来检查V8所产生的机器语言。所产生的指令串可以和V8代码比较，以便显出它的特性。  例如，在执行图14a所示的JavaScript函数时，就会产生一个如图14b所示的x86机器语言指令串。此函数在第39个指令中被呼叫，是个「n+one」加法。在JavaScript中，「+」操作数指示数字变量的加法，以及字符串的连续性。编译器不是产生代码来判决这是哪一种，而是呼叫函数来负责判断。 图14 V8从JavaScript代码产生的机器语言加法处理被转换成函数呼叫的机器语言（a、b）  如果图14的函数稍做更改（图15），那图14b的函数呼叫就会消失，但会有个加法指令（第20），及分支指令（JNZ的若不是零就跳出，第31）。当使用整数作为「+」操作数的操作数，V8编译器在不呼叫函数下会产生一个有「加法」指令的指令串。如果发现操作数（在此为「n」）成了Number对象或String对象等的指标（pointer）， 就会叫出函数。「加法」只会发生在当两个「+」运算的操作数都是整数时。在这种情况下，因为可以跳过函数呼叫所以执行就会比较快。 图15 V8从图14之JavaScript中所产生的机器语言，经小幅修改  此外，0x2会加上「加法」指令，因为为最低有效位（least significant bit, LSB）被用来区别整数（0）和指标（1）。加0x2（二进制中的十）就如同在该值加上1，LSB除外。在jo指令的溢位（overflow）处理中，利用测试和jnz指令来判定指标，跳到下游处理（注1）。  这类的窍门在编译器中到处都有。然而，产生器代码也透露了编译器的限制。具传统最佳化的编译器可以针对图14和15产生完全一样的机器语言，这是由于常数进位的关系。然而V8编译器是在抽象语法树*（abstract syntax tree）单元中产生代码，因此在处理延伸多个节点时就没有最佳化。这在大量的push和pop指令也非常明显。图16显示了C语言里相同的处理提供参考。由于C和JavaScript之间的语言规范不同，因此所产生的机器语言是图14和图15的不同，这和编译器的性能无关。  图16 C编译器从C代码所产生的机器语言所产生的机器语言比V8所产生的干净许多（a、b），大部分是因为C和JavaScript语言规范的差异所致。  注1：当溢位信号出现时，jo指令会跳至特定的位址。测试指令将逻辑AND结果反映成零和符号指标等。除非零信号出现，否则jnz指令会跳至特定的位址。  Abstract syntax tree抽象语法树：在树状架构中代表程序架构的数据。  附录：熟悉OOP的程序员之参考 JavaScript没有类，但为了让熟悉使用类（面向对象的代码）之程序员更方便使用，可以使用「new」的操作数来建立对象，就像在Java一样。在「new」操作数之后会定义一个特别的「constructor」建构函数（图B-1 a, b）。  然而，即使没有建构函数，也可以建立对象（图B-1c）和设定属性的（图B-1 d）。JavaScript对象的属性和法等随时都可以新增或删除。  除了用点标记（dot notation）存取JavaScript属性以外，也可以使用括号，建议散列(hashing)存取（图B-1 e、f）或是以变量特定属性名称字符串（图B-1 g）。从这些范例中明确显示JavaScript对象的设计是为了使用哈希表。12345678910111213141516171819202122232425a) 定义建构函数「Point」function Point(x, y) { // this是指它自己 this.x= x; this.y= y;}b) 当增加新的及呼叫建构器函数时所建立的对象var p= new Point(10, 20);c) 没有建构器函数也可以建立对象var p= { x: 10, y: 20 };d) 可以自由地在对象上新增属性p.z= 30;e) 使用点标记存取属性var y= p.yf) 使用括号之散列(hashing)存取var y= p[\"y\"];g) 也可以使用变量进行散列(hashing)存取var name= \"y\";var p[name]; 本文虽然写于2009年V8刚刚推出的时候，其中仍对理解V8有很大帮助。 原文地址：http://techon.nikkeibp.co.jp/article/HONSHI/20090106/163615/ 繁体中文版地址: http://www.greenpublishers.com/neat/200901/3coverstory.pdf *本文是以繁体中文版为基础重新修订的。看起来繁体中文版本多为机翻后人工校正的，除去两岸的专业词汇不同外，仍有不少不通的地方。最明显的就是将class翻译为层级。 转自：http://www.xuanfengge.com/why-v8-so-fast.html ",
            "path": "/2016/05/02/「转」为什么V8 JavaScript引擎这么快/"
        },
        {
            "title": "「ecmascript6」promise介绍与nodejs实践运用(q.js)",
            "date": "2016-05-01",
            "content": " 介绍看了网上许多介绍 Promise 的文章，终于知道 Promise 是什么，干什么的了。首先需要指出的是，promise是es6提出的新标准之一，那么提出这个标准是用来做什么的呢？写过js代码的童鞋一定知道，异步回调函数是js的一大特点，那么异步回调函数带来的问题是什么呢？会造成函数嵌套过多，不宜于后期代码的维护，许多的({})也容易把我们搞得晕头转向。那么promise便是用来解决该问题。那么es6提出这个标准，那么就得有人按照这个标准来实现吧，于是百家争鸣，出现许多库(以便在非浏览器环境下使用)，在这我介绍 q.js.q.js github地址 使用 安装q.js npm install q 使用   使用Q.nfcall 12345678var fs = require('fs'), Q = require('q');var promise = Q.nfcall(fs.readFile,'run.js');promise.then(function(data){ console.log(data); },function(err){ console.err(err); });  或者可以简写为下面 promise.then(console.log,console.err);  使用Q.deferd 123456789101112var preadFile = function(file){ var deferred = Q.defer(); fs.readFile(file, function (error, text) { if (error) { deferred.reject(new Error(error)); } else { deferred.resolve(text); } }); return deferred.promise;};preadFile('run.js').then(console.log,console.err);  还可以用Q.all实现同步方式 12var promise = Q.all([Q.nfcall(fs.readFile,'run.js'),preadFile('event.js'),preadFile('nofound.js')]);promise.then(function(data){console.log(data.toString())},console.error);  因为nofound.js不存在所以会抛出异常，其他文件即使存在也不会正确执行.  多层嵌套异步方式 123456789101112131415161718192021222324252627var preadFile = function(file){ var deferred = Q.defer(); fs.readFile(file, function (error, text) { if (error) { deferred.reject(new Error(error)); } else { deferred.resolve({data:text,file:file}); } }); return deferred.promise;};preadFile('run.js') .then(function (d) { console.log(d); return d.file+'xx'; }) .then(preadFile) //上面return d.file 传递到preadFile中 .then(function (d) { console.log(d); return d.file; }) .catch(function (e) { console.log(e); }).done(function (e) {//最后一个then return的参数 console.log(e); });  上面的代码run.js将会正确输出，但是因为不存在run.jsxx文件所以会捕获错误，但不影响run.js的输出。   尾声更多的用法参考q.js github地址原来我以前一直使用的 $.ajax({}).fail().done() 正是promise方式的一种。 ",
            "path": "/2016/05/01/「ECMAScript6」Promise介绍与nodejs实践运用(q.js)/"
        },
        {
            "title": "「项目拾遗」谈谈websocket",
            "date": "2016-04-30",
            "content": " 前言在2015年寒假期间，我完成了考友无忧项目的考友互动板块模块，主要是基于websocket实现的公共聊天室/一对一好友聊天/实时消息推送，基于websql实现的历史聊天纪录存取。项目地址 http://moyuyc.xyz/autoexam/ 测试用户 moyumoyu，密码 moyumoyu 关于websocket通过websocket，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。websocket数据传输不是采用的http协议，而是自己定义的协议。具有传输数据量少的特点。chrome控制台中可以查看到这一次握手动作 预览 实时好友聊天 实时消息推送  实现前端 利用jQuery封装的 websocket 接口 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192(function($) { $.websocket = function(options) { var defaults = { domain: top.location.hostname, port:80, path: \"\" }; var opts = $.extend(defaults,options); // 注意：必须为绝对url，websocket不支持同源策略。 var szServer = (top.location.protocol == 'http:' ? \"ws://\" : \"wss://\") + opts.domain + \":\" + opts.port + \"/\" + opts.path ; var socket = null; var bOpen = false; var t1 = 0; var t2 = 0; var messageevent = { onInit:function(){ if(!(\"WebSocket\" in window) && !(\"MozWebSocket\" in window)){ if(!Boolean($.cookie('session'))) { $.moyuAlert('您的浏览器不支持websocket，将不能使用好友功能。'); $.cookie('session', true); } return false; } if((\"MozWebSocket\" in window)){ socket = new MozWebSocket(szServer); }else{ socket = new WebSocket(szServer); } if(opts.onInit){ opts.onInit(); } // 成功建立连接时触发 socket.onopen = messageevent.onOpen; // 接受到服务器的数据触发 socket.onmessage = messageevent.onReceive; // 发生错误时触发 socket.onerror = messageevent.onError; // 连接关闭时触发 socket.onclose = messageevent.onClose; }, onOpen:function(event){ bOpen = true; if(opts.onOpen){ opts.onOpen(event); } }, onSend:function(msg){ t1 = new Date().getTime(); if(opts.onSend){ opts.onSend(msg); } // 发送数据至服务器 socket.send(msg); }, onReceive:function(msg){ t2 = new Date().getTime(); if(opts.onReceive){ opts.onReceive(msg.data,t2 - t1); } }, onError:function(event){ if(opts.onError){ opts.onError(event); } }, onClose:function(event){ if(opts.onClose){ opts.onClose(event); } // 关闭连接 if(socket.close() != null){ socket = null; } } } messageevent.onInit(); this.send = function(pData){ if(bOpen == false){ return false; } messageevent.onSend(pData); return true; } // this.close = function(){ messageevent.onClose(); } this.bOpen=bOpen; return this; };})(jQuery);  利用封装好的 jquery.websocket 建立websocket对象，建立与服务器的长连接 1234567891011ws = $.websocket({ // 服务器的连接的url path: 'autoexam/websocket/chat?tag='+window.axTag, onReceive: function (data, time) { /** * data : 服务器来的数据 * time : 接受数据的时间戳 */ }, onClose: function () {}});  发送数据至服务器和关闭连接 12345ws.send(JSON.stringify({ to:'', //'common'->公共聊天室; 用户名->好友聊天 content: um.getContent() // 发送的内容}));ws.close();   后端 (Java)基本数据集12345678910111213141516171819202122232425@ServerEndpoint(value = \"/websocket/chat\",configurator=GetHttpSessionConfigurator.class)//configurator是为了得到HttpSessionpublic class ChatServer { // 当前存在的所有websocket连接(被封装在ChatServer对象中) public static final Map<String,List<ChatServer>> connections = Collections.synchronizedMap(new HashMap<>()); // 下面4个Map对象是为了实现 // 发送添加好友请求/被拒绝添加好友/被通过添加好友/发送消息接受 接受人当时不在线。 // 当下次这4个Map中的key上线时，再发送相关的信息。 ...比较拗口 // 暂时存放添加好友请求(未被处理)的Map，key->待接受人，value->发送请求人集合 public static Map<String,Set<String>> rev_sender = new ConcurrentHashMap(); // 暂时存放添加好友求被拒绝的Map，key->被拒绝人(发添加请求人)，value->拒绝人集合 public static Map<String,Set<String>> ignore_rev_sender = new ConcurrentHashMap(); // 暂时存放添加好友求被允许的Map，key->被允许人(发添加请求人)，value->允许人集合 public static Map<String,Set<String>> pass_rev_sender= new ConcurrentHashMap(); // 暂时存放好友聊天内容的Map，key->接受消息人，value->消息内容(包括时间/内容/发送人) public static Map<String,List<JSONObject>> remain_msgs = new ConcurrentHashMap(); private String name; // websocket会话对象 public Session session; // httpsession会话对象 public HttpSession httpSession;} 细节考虑 为了防止服务器重启/关闭导致数据丢失，所以在服务器关闭时触发的事件中，将必要的数据写入文件中；在服务器启动时触发的事件中，再将数据写回内存。 12345678910111213141516171819202122232425262728293031323334public static void writeData(String path) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(path)); oos.writeObject(rev_sender); oos.writeObject(ignore_rev_sender); oos.writeObject(pass_rev_sender); // 因为JSONObject类没有implements Serializable，所以只好将JSONObject转换为String对象写入文件 Map<String,List<Object>> new_remain_msgs = new ConcurrentHashMap<>(); for(String key:remain_msgs.keySet()){ List<JSONObject> l = remain_msgs.get(key); List newl = new LinkedList<>(); for(JSONObject jo:l) newl.add(jo.toString()); new_remain_msgs.put(key,newl); } oos.writeObject(new_remain_msgs); oos.flush(); oos.close();}public static void loadData(String path) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(path)); rev_sender = (Map<String, Set<String>>) ois.readObject(); ignore_rev_sender = (Map<String, Set<String>>) ois.readObject(); pass_rev_sender = (Map<String, Set<String>>) ois.readObject(); Map<String,List> new_remain_msgs = (Map<String, List>) ois.readObject(); ois.close(); for(String key : new_remain_msgs.keySet()){ List newl = new_remain_msgs.get(key); List<JSONObject> l = new LinkedList<>(); for(Object o:newl) l.add(JSONObject.fromObject(o)); remain_msgs.put(key,l); }}  用户在未进入考友互动模块时，应该也能实时地接受相关的添加好友请求，新的消息请求。首先，在其他非聊天界面，设置 window.axTag=\"login\"; 而在聊天界面中设置 window.axTag='chat'; 回到上面的建立websocket连接的代码 path: 'autoexam/websocket/chat?tag='+window.axTag 这下就明白了，通过连接的url串传递是当前用户在哪类页面，然后进行不同的数据传输。  …   小结与源码地址该在线考试交友系统是我独自花费了较大心血完成的项目，我也从中获取了许多，包括技术细节上的，项目规划上的。再推荐下该项目 http://moyuyc.xyz/autoexam还可以 Fork It最后做下功能总结  发送邮件 考卷Word导出 图像上传切割与旋转 聊天图片可放缩 聊天历史记录 新消息提示与跳转 后台题库excel批量导入 …  ",
            "path": "/2016/04/30/「项目拾遗」谈谈websocket/"
        },
        {
            "title": "谈谈javascript之数组对象深拷贝",
            "date": "2016-04-30",
            "content": " 回忆上周百度面试问了我关于数组的 clone 方法的实现，当时没来得及细想，然后口头上说  数组就是一串数据序列，可以遍历然后进行深拷贝即可。  关于细节实现的东西都没想，然后面试官那边好像就无语了… 不过好在我提到了 深拷贝 这个关键字。 再探clone浅复制先看第一段代码123Array.prototype.clone = function(){ return this.slice();} 乍看一下，好像挺快捷方便的就完成了。实际上，懂得c++/java中浅拷贝/深拷贝的人一看便知道这只是实现了浅复制。测试代码如下，123456var arr = [1,new function (x){ this.x=x; }(3)];var clone = arr.clone();clone[1].x=1;console.log(arr[1].x) // 1 可以看到，clone[1].x改变导致arr[1].x改变，图示如下 深复制1234567891011Object.prototype.clone = function () { var clone = new this.constructor(); //开辟新内存空间，保证clone出来的对象也有一个属性能够指向原对象的原型对象。 for(var k in this){ if(!this.hasOwnProperty(k)) continue; if(typeof this[k] === 'object') clone[k] = this[k].clone(); else clone[k] = this[k]; } return clone;}; 利用递归来实现Object实例的深复制(重新开辟一份内存空间)，如图因为Array也属于Object，上面的代码也适用于Array 不足之处：不能对DOM元素结点进行复制 ",
            "path": "/2016/04/30/谈谈JavaScript之数组对象深拷贝/"
        },
        {
            "title": "从定时器到 web worker",
            "date": "2016-04-29",
            "content": " 前言首先，JavaScript是单线程执行的，也就是同一时间只有你的一份js代码在运行（不论你cpu几核，os是以线程为基本单位分配任务调度的，为了利用多核cpu的优势，HTML5提出Web Worker标准，本文会讲到），那么JavaScript中的setInterval和setTimeout api是什么工作原理呢？ JavaScript事件循环如图，EventEmitters为事件发起者，比如你点击按钮，异步请求完成触发回调函数，定时器时间到了，事件触发…（这些是由多线程的浏览器来实现的）；Events为事件队列，表示亟待处理的事件，Event Handlers表示从事件队列中取出队首的事件，在堆、栈中的进行函数调用，语句运行。明白了JavaScript的事件循环后，我们再来看看setInterval和setTimeout。 再探 setInterval setTimeout定时器原理先看下面这段代码1234567891011console.log(1);setInterval(function(){ console.log('interval');},1);var i = 10;while(i-->0);console.log(2);setTimeout(function(){ console.log('timeout');},0);console.log(3); 从事件循环角度解析下这段代码，首先执行console.log(1); 没问题，So Easy，然后继续，执行到setInterval，时间为 1ms ，于是在1ms之后将setInterval的处理函数加入到事件队列中，于此同时，继续执行直到setTimeout，于是在0ms之后将setTimeout的处理函数加入到事件队列中，最后执行完console.log(3);后，再从事件队列中取事件处理。也就是说，定时器中的时间指的是过多少时间将处理函数加入到事件队列中，而不是立即执行明白了上面的解释后，如果123var i = 10;while(i-->0);console.log(2); 这段代码执行时间大于1ms，则setInterval在setTimeout之前加入事件队列，输出就应该如下123456123intervaltimeout... 重复的定时器setInterval问题暴露 场景重现某个click事件处理程序使用setInterval设置了一个200ms时间间隔的重复定时器，click处理程序花了300ms时间，定时器代码花了400ms时间。 问题存在     时刻 描述     0ms 进入click事件处理程序   5ms 创建setInterval定时器   205ms 定时器事件添加至事件队列   300ms click处理完成，取出定时器事件，进入定时器代码   405ms 事件队列中不存在定时器代码，添加定时器事件至队列   605ms 事件队列中存在定时器代码，定时器事件未至队列   700ms 定时器代码执行完毕，取出下一个事件队列中事件（定时器代码）    可以看到，300ms-700ms执行完定时器代码后，紧接着下一个事件依旧是定时器事件，而不是预想的200ms 问题解决可以用下列链式setTimeout解决该问题1234setTimeout(function(){ //do something setTimeout(arguments.callee,interval);},interval); 举一反三html5新增的api requestAnimationFrame，原理与setTimeout一致，详细参考requestAnimationFrame Vs setIntervalsetTimeout,requestAnimationFrame注意放处理函数最后。 JavaScript优劣 优点单线程简单，通过事件循环实现并发。而不是传统的请求-等待-响应模式。  缺点单线程，不能充分利用多核CPU性能。   Web Workers为了解决JavaScript单线程带来的不便，HTML5引入了Web Workers规范。能够解决长时间运行的JavaScript脚本导致页面”冻结”的问题。效果对比可以查看KMenus图像算法优化前 和 KMenus图像算法优化后选择Image Choose，选择图片，点击画板放置图片后，点击K-Menus后，你会发现好像没发生什么事情一样。其实在后台已经创建了一个Worker，处理冗长的K-Menus图像聚类算法了，而你能继续享受流畅的用户体验。耐心等待一段时间，处理的结果才会返回回来，显示在界面上。 代码如下1234567var worker = new Worker(\"js/algorithm.js\");//发送data至worker中worker.postMessage(data);//worker处理完数据后的回调函数worker.onmessage = function (ext) { var data = ext.data; //worker处理后返回的数据} js/algorithm.js12345onmessage = function (evt) { var data = evt.data;//worker接受到的数据 //do something about data postMessage(data);//发送处理后的数据} ",
            "path": "/2016/04/29/从定时器到 Web Worker/"
        },
        {
            "title": "git捣鼓记之「pull request」",
            "date": "2016-04-28",
            "content": " 前言 昨天，又捣鼓了一会儿git，因为想把我关于NexT主题的修改提交到原作者github上，以方便更多人使用。 修改之处 原版的主题中，有三种Schema（Muse/Mist/Pisces），在主题的配置文件_config.yml中，有sidebar:position属性，但是却反人类的仅仅只支持Pisces  Pisces设置sidebar:position为left后，效果如下(图片来自原作者博客)：  于是乎，我便「一言不合，开始动手」，研究起其他两个主题的sidebar源码起来。有了原作者代码的参考，照葫芦画瓢，不一会儿也修改好了。为了让更多人知道我闲的蛋疼的举动，于是我便打算 Pull Request. Pull Request！Fork 首先，找到你需要修改的项目，Fork It！ Clone Fork完成之后，找到你Fork的项目。 git clone {ssh or https} cd {name} # 进入项目目录 New Branch & Fix Bug Clone之后，切换分支（branch） git checkout -b fix-bug  然后在本地尽情地修改吧，修改完成后 git add . && git commit -m \"fix-bug\" git push origin fix-bug Pull Request 提交你的修改至github后，切换branch至fix-bug点击Compare & pull request按钮，然后写下你修改内容的说明就OK了 Wait To Be Merged 目前还没有同意Merge. = = 参考资料http://www.zhihu.com/question/21682976 ",
            "path": "/2016/04/28/git捣鼓记之「Pull Request」/"
        },
        {
            "title": "play css3 animation",
            "date": "2016-04-27",
            "content": " 将鼠标移动至黑色方格上，或者点击黑色方格。  关于CSS3动画transform? translation?转换（transform） 顾名思义，就是一些转换动作，如放大缩小( scale )，平移( translate )，旋转( rotate )，翻转( skew )等。就是关于二维图形与三维模型的转换动作（矩阵变换，图形学中的东西，这里不深究）。关于，三维空间的基本转换和少许组合转换，我做过类似的Demo (请使用最新版的主流浏览器查看)参考资料  CSS3 2D 转换 CSS3 3D 转换  过渡（translation） 在CSS中的属性改变后，为了使用户体验更加良好，需要使用到过渡效果，使得属性变换更加平滑。 参考资料  CSS3 过渡  Animation?动画（Animation） 可以将一系列复杂的css属性变化活动定义为一个动画，并且规定触发动画的次数或其他相关设定。 参考资料  CSS3 动画  关于示例动画第一个「活跃」的蓝色方块首先定义动画123456789@keyframes animated_div{ 0% {transform: rotate(0deg);left:0px;} 25% {transform: rotate(20deg);left:0px;} 50% {transform: rotate(0deg);left:500px;} 55% {transform: rotate(0deg);left:500px;} 70% {transform: rotate(0deg);left:500px;background:#1ec7e6;} 100% {transform: rotate(-360deg);left:0px;}} @keyframes animated_div 定义了一个名为 animated_div 的动画，这样我们就可以直接在后面使用这个动画了。xx% 表示的是动画的进度，即最开始对应 0% 。因为各公司浏览器都想自己搞垄断，所以为了兼容主流浏览器不得不重复一段代码了123@-webkit-keyframes animated_div{/*同样定义*/}@-moz-keyframes animated_div{/*同样定义*/}@-o-keyframes animated_div{/*同样定义*/} 使用动画123<div style='margin:30px;position:relative;animation: animated_div 2s infinite;padding:10px;display:inline-block;'> CSS3 Animation</div> margin padding 是用来美化距离的，display:inline-block; 将该元素变为行内块，不然 div 默认为块元素，将独占一整行。position:relative; 是为了让 left right bottom top 凑效。animation: animated_div 2s infinite; 使用刚刚我们定义的动画，动画的周期为2s，infinite 表示无限制的进行动画！ 这样你就能看到第一个动画啦！ 关于两个小黑块首先是定义样式 CSS 123456789101112131415161718192021.magic-div{ width: 56px; height: 50px; padding: 10px; line-height:0;/* * */ background-color:black; cursor:pointer;}.magic-div>span{ background-color:white; margin-top:20px; vertical-align: top; width:100%; height:2px; display: inline-block; transition:all .6s; // 所有属性都有过渡效果}.magic-div>span:first-child{ margin-top:3px;}  HTML 12345<div style='display:inline-block;' class='magic-div magic-div-right'> <span></span> <span></span> <span></span></div>   这样你就能看到一个黑块中含有三条水平横线啦 动画控制 第一个黑块12345678910111213141516171819202122var div = document.querySelector('.magic-div-right');function bind(elem,type,fn){ elem[type]=fn; elem.addEventListener(type,elem[type]);}bind(div,'mouseenter',function(e){ var first = this.firstElementChild,last = this.lastElementChild, mid = first.nextElementSibling; first.style.transform='scale(.5) translate(35px,25px) rotate(45deg)' last.style.transform='scale(.5) translate(35px,-25px) rotate(-45deg)' mid.style.opacity='1';});bind(div,'mouseleave',function(e){ var first = this.firstElementChild,last = this.lastElementChild, mid = first.nextElementSibling; first.style.transform=last.style.transform=''; mid.style.opacity='1';})bind(div,'click',function(e){ var first = this.firstElementChild,last = this.lastElementChild, mid = first.nextElementSibling; first.style.transform= 'rotate(45deg) translate(15px,15px)'; mid.style.opacity='0'; last.style.transform = 'rotate(-45deg) translate(15px,-15px)';});   至于为什么需要定义一个 bind 函数，应该聪明的读者已经知道我要干什么了，bind 函数中 elem[type]=fn; 将事件处理函数绑定到元素中了，在原生js中，元素有 click(),focus(),blur()…，这样的方法，可以直接调用对应的事件函数，但是却没有类似 jQuery 中的 mouseenter(),mouseleave() 方法。我这样做，能达到类似 jQuery 中的效果。 然后是函数中，一大堆的 transform,scale(xx),translate(xx,xx),rotate(xx)，也不难理解，只要上过初中平面几何就能明白了。至于为什么会出现动态的效果，那都是多亏了样式中的 transition:all .6s;  第二个黑块第二个黑块完全就是第一个黑块的孪生兄弟，可能有人会说了，这还不简单吗？直接copy第一份的代码，然后修改一下元素不就行了吗？这样的确可以，但是我是用的是另一种方法，使得代码缩减了许多。12345678910var otherdiv = document.querySelector('.magic-div-copy');bind(otherdiv,'mouseenter',function(){ div.mouseenter.call(this);})bind(otherdiv,'mouseleave',function(e){ div.mouseleave.call(this);});bind(otherdiv,'click',function(){ div.click.call(this);})   div.mouseenter.call(this); 意思是将div.mouseenter方法调用，但是不是被div调用，而是被 this （即otherdiv）调用。call 属于 Function原型中的方法，第一个参数是调用该函数的对象，后面还可以跟上函数的参数。apply 对比 call，也是换汤不换药，不过函数的参数是以数组方式传入的。 ",
            "path": "/2016/04/27/play_css3_Animation/"
        },
        {
            "title": "「转」也许，这才是大学真正的意义",
            "date": "2016-04-26",
            "content": " 听过太多道理依然过不好这一生，上了这么多年大学依然不知道为什么要如此为难自己。 可是突然一瞬间一觉醒来，我似乎想明白了大学真正的意义：所谓的大学，不过是让你清楚的明白，离开父母离开朋友离开一切庇护你的港湾和结实的依靠，只身一人在外地的你，在这个小型社会的你，在这个鱼龙混杂之地的你，在这个无人懂无人在乎的环境的你，是否依然能坚强的拥抱自己，为自己铸造一片属于自己的清幽之地，是否有勇气面对这一切陌生的未来和迷茫的自己。 以下这些，我希望你我都懂，我不是教你怎么做，而是告诉你怎么认清。你可以时刻提醒自己，时刻问自己，这些你确定都知道吗？   01  你不是世界的中心，地球没你照样转行  大学是真正意义上的远离家长远离熟悉的城市，只身一人拉着行李坐在通往陌生地点的车，有新奇也有恐慌。以往习惯了身边朋友的迁就，父母的宠溺，老师的夸奖，同学的羡慕，突然的你在这个大学里变得如同一颗无人问津的小草，你再也不是那个被那么多人围拥仰望的光芒，你被淹没在人山人海的世界里，找不到自己存在的意义。以往你可以任性可以张扬，不过是因为身边有一群足够忍让你在乎你的人，可是大学这个小型社会，来自五湖四海的同学，千万人中你不是唯一，也没有人会过度在意你如何怎样。 在这里，没有太多人可以容忍你任你胡闹，你不是世界的中心，离了你地球照样转行，所以少把以前的小性子和直言直语不顾及人尊严的话不动脑子轻易的说出来，也切记什么事情都想着别人一定要考虑你的想法，因为一点小事就和别人吵得不可开交，你长大了，要学会心平气和的处事，从容的面对生活了。 02  除去一切避风港，你还有地方可藏吗？  少了父母的庇护，朋友的陪伴，无依无靠的你，能够挺过去一切困难吗？ 小的时候受伤了难过了，我们总会哭着喊着找妈妈，可是离开父母身边的你，再也不能在哭泣时躲到他们温暖的怀抱里，甚至有时候你会发现，即便你难过委屈哭泣的时候，却是不敢打电话给他们的，因为你会怕他们担心怕他们着急，即便告诉了他们他们也顶多在电话那头安慰你几句，无法给你一个怀抱，也许听听他们的声音就足够了，可是你确定你不会在听到他们声音的时候哭出来吗？我们都听过这么一个例子，小孩子当着外人的面摔倒了会拍拍身上坚强的站起来，可是爸妈一关心的问一句没事吧就会忍不住嚎啕大哭。 大学一开始肯定会有一些抵触，甚至对父母的思念愈渐浓烈，委屈时更是想家，这就是在告诉你，究竟什么才是最能让你内心安定下来让你温暖的地方，除去家这个温暖的避风港湾，很多时候我们根本无地可藏，只有父母才会是那个不管你如何都不会离开你抛弃你的人。 所以，多给父母主动打几个电话，他们在城市的另一边正挂念着你，也无比期待听见你的声音。 03  你足够坚强应付一切吗？你有能力拼搏自己想要的未来吗？  也许大学真正的意义就在这里，让你清楚自己的能力究竟是个什么样子，让你看看自己孤身一人能否应付一切困难，能否配得上自己想要的生活，能否足够为自己撑起一片天。 遇到困难的你怎么办，生活费不够的你怎么办，厌学的你怎么办，和同学关系处理不好的你怎么办，这些问题你都能轻而易举的解决吗？这些难关你都能渡过吗？好好想想这些问题，才会清楚的知道自己究竟几斤几两。 大学就是一个磨砺的过程，首先不考虑你学习成绩怎样，首先在生活方面就是一个难题，为的就是锻炼你自己一人面对这世界所能承受的程度和处事的能力。我们首先要学会的就是勇敢独立和坚强，让自己内心强大起来，让自己努力起来。 04  你懂的人情世故尔虞我诈吗？  竞争，是个亘久不变的生存法则，也许大学并不像社会上那么激烈，但它的竞争意识和观念也已经显现出来了。例如在学生会就是一个很好的锻炼机会，它是一个相当于公司类型的学生组织，下设很多部门，各部门的人分工合作共同促进学校纪律严明。但是在这个部门之下，已经有的人开始暗地里为了部长主席之位而讨好学哥学姐讨好老师，我并不是告诉你也要这么做，而是以防自己受伤，要看清这一切本质，别傻傻的被人卖了还不知道。以后工作上有时候这种问题出现的次数更多，这个社会不需要傻白甜，亲爱的，有的时候你那不是单纯而是傻，如果你到现在还不知道这个社会的生存法则你就真的要被社会所抛弃了。 有时候表面相处好的不一定真心就是朋友，有时候这个人嘴上讨厌另一人但也会笑着聊天，有时候我们要学会违背自己的心愿去做一些自己不喜欢做的事，因为，这就是复杂的人生啊。愿你知世故而不世故，愿你能看清社会的黑暗仍然永葆善良。 05  你能够自己挣够一月生活费吗？  你心安理得的接受父母打来的生活费，心安理得的拿着钱四处挥霍，心安理得的买着各种衣服包包，在网吧里昏天暗地的打游戏，而你是否想过，你浪费的钱是父母多少汗水换来的？如果让你自己赚钱，你能赚够自己的生活费吗？ 记得大一周末第一次去兼职发传单，顶着炙热的太阳站在人来人往的马路上，把手里的传单一张张递出去，换来的可能是别人的无动于衷，还要一站一整天，又要担心遇到城管，中午可能就吃个面包填饱肚子，一直到下午领到五十块钱工资，那一刻才知道有多么心酸，钱有多么难挣。回去的路上紧紧攥着五十元心却没来由的酸涩，借着夜晚的车窗嘲笑当初那个挥霍无度不知节俭的自己有多可悲。 由此可以想象我们的一个月生活费包含了多少父母的心血，当你再挥霍的时候请想一下他们头上的白发脸上的皱纹和手心的粗糙，以及那双炙热的宠溺你的眼神。 既然知道钱有多难挣，我们就该学会替父母分担一些，学会合理的计划安排自己的开支，不铺张浪费不攀比，适当的兼职也可以锻炼自己的能力和为自己得到一份额外的收入。 06  你身边的朋友是真心的吗？身边的恋人是可靠的吗？你们能走到最后吗？  逢人只说三分话，不可全抛一颗心。你身边的人说不定哪天就在背后陷害了你损害了你的利益，或者背地里和其他同学一起说你的坏话。交朋友真的不必在多，到最后你就会发现一辈子能有两三个知己就已经足够了。交朋友看得是质量而不是数量，当你有困难需要借钱的时候你身边还剩下几个所谓的朋友会帮你。 你可以谈恋爱，但你要清楚你已经不小了，感情不是游戏，你要找到一个真正适合真正对你好的人，外表真的不重要，对方的人品、是否有上进心才是你该优先考虑的。所谓毕业季就是分手季其实不用太担心，如果你们感情真的牢固，一切的问题都不是问题。 07  有时候图书馆比宿舍更安静，有时候宿舍比图书馆还安静。  其实我极度不喜欢宿舍，有时候受不了它的喧嚣逃去图书馆，沐浴在书海里，可以一坐一整天。有时候宿舍又太过安静，每个人人抱着一个手机躺在各自床上，没有交谈没有声音，寂静的比图书馆还可怕。这两种氛围我都不太过喜欢，喧闹的让我静不下心来，安静的又让我觉得可怕。 其实大学宿舍无非就是一个让你有一个可以归宿的地方，大学的室友也不一定是可以和你心灵相通的，人越长大对于朋友的理念越来越浅薄，也越来越不愿随便，一切都看你怎么选择。 有时候和室友难免闹矛盾，但是你该知道，我听过那么一句话，“大学不要和室友闹矛盾，因为你压根无处可去。” 你已经长大了，该成熟了。成熟就是学会把委屈咽下，把委屈藏在心底，不再对别人任意揭开，学会自我疗伤自我调解，自己消化掉坏情绪，不再因为一点小事就火急火燎，要学会心平气和的处事，以更好的状态迎接生活。生活已经不允许你再任性，而真正成熟的你也知道对什么人在什么时候不该任性。 08  你可以不努力，但不要嘲笑别人努力。  看到有的同学每天一大早起来去教室自习，你捂紧了被子，心里暗暗骂了声“神经病。”看到有的同学周末不出去玩，而是抱着一堆学习资料去自习室，你不屑的暗暗嘲笑书呆子。当你在宿舍里抱着手机追韩剧，其他同学坐在床上看书，你抬头瞧一眼暗暗鄙视别人装。可殊不知，其实最令人瞧不起的是你自己，到头来被嘲笑的是你自己，最后一无所有的仍然是你自己。 你可以不努力，但不要嘲笑别人的努力，也许别人的努力在你眼里一文不值，可是，所有的事情最终都会有一个答案，时间会告诉你什么是对什么是错什么该珍惜，更会把你的信誓旦旦换成打在脸上的一巴掌。你有多堕落，时光就有多疼痛。你有多嘲笑别人，别人就有多成功，而你嘲笑的最后都变成了你所后悔的。 09  你想清楚未来要做什么了吗？你该考的证都考出来了吗？  你以后要做什么？你的梦想是什么？你将来要从事什么？你的英语四级考出来了吗？ …… 你已经大学了，很多事情已经不容许你再往后拖延了，你要为自己的未来所提前做打算，不是等到毕业后还一脸茫然不知道该去什么，那时候再去着急已经太晚了。所以从现在开始你就要清楚的知道自己将来要从事一个什么行业，并怎么去做。 譬如会计专业，你现在就最好能考出会计从业证，为自己面试时争取一个更好的机会，当然，最好还能考出来初级，在一个从业和初级的水平下，我相信大部分公司都会选择有初级证书的同学。再比如四级，在校内最好能考出来，它也是你简历上可以优先让公司录取的一点，多一个证书其实你就相应的多一个机会。 机会都是留给有准备的人。 010  讨厌本专业？讨厌学习？  我听到过很多人说讨厌本专业，后悔报了本专业，又没兴趣，所以破罐子破摔，任由自己一步步堕落下去。可是你别忘了，这是你自己当初的选择，你要为它所负责。 生活中我们总会遇到很多我们不喜欢但必须要做的事情，例如你生病不喜欢吃药不喜欢打针可是你还是必须要去做，否则你的病只会越拖越严重，到最后就不是吃药这么简单了。 一个人把自己喜欢的事情做好是认真努力，把自己不喜欢的事情还能做好才是最值得人钦佩的，哪怕你不喜欢，也要善于发现它的乐趣，为自己找到一个坚持下去的理由，而不是在心里就一次次否定“我不喜欢我肯定做不好。”你有试着去做吗？你有真的去努力吗？ 如果你实在不喜欢，将来也不打算从事本行业，那么，你就要学着从其他方面着手，考虑自己该怎样去做才不荒废大学时光，而不是既然我不从事这个专业那以后学了也就没用了，既然你对这个不感兴趣，那必然会有你所感兴趣的东西，把你所感兴趣的去做好也是一件本事。 例如有的时候我就不喜欢男生打游戏，我认为又耽误时间又浪费钱，你可以去打游戏，但是我想说，如果你做不到像人家打游戏能打出冠军来的，就不要以为自己多了不起，一个人不管做什么从事什么职业，只要他有信心责任心和坚持，并且把这件事情做好，那么任何职业都是好的。学习只是为了给你提供更多的机会，而如果你能从其他方面找到更多的机会你可以不去学习，怕的就是你不学习还没有可以任性的优点，最终一事无成！ 011  你可以不化妆不打扮，但请着装整洁  我们走在校园里总是随处可见化着妆穿着时尚的女生和打扮帅气的男生，任是谁都忍不住多看他们两眼，而那些长相平凡衣着纯朴的自然被淹没在人群中毫不起眼。这时就会有人嫉妒，阴阳怪气的说别人骚气，肤浅，然而，事实真的如此吗？ 爱美之心人皆有之，把自己打扮的漂亮点错了吗？我们不可以用批判的眼光去这么看待别人。不过大学生的我们，并不是需要人人化妆，衣着整齐干净会给人一种很舒服的感觉，如果你都懒得打扮自己收拾自己，你还怎么指望别人怎么看待你，如果你连自己都不尊重自己，让别人怎么尊重你。 外表与穿着是第一印象的法宝，不要让自己给别人留下不好的印象。 012  现在不旅游以后更没时间了  我们总是说，时间还很多，未来还很长，我们可以骑马喝酒走四方，不必急于一时，于是一拖再拖。可是，计划永远赶不上变化，有些事你当下不去做将来可能真的没有时间了。就像是我们小时候写作业，总爱说“没事、时间还多呢，开学早着呢”，可是一眨眼全都在开学前一天晚上拼命加班，把所有的事情都堆在了一起。 你想想看，现在我们是学生，时间最多最充裕，周末假期……可是以后一步入社会，我们就开始为了生活打拼，为了财米油盐奋斗，为了能有一席之地而挣扎，我们天天忙的焦头烂额，在生活与工作之间奔波，面临的事情越来越多，很多东西真的开始顾及不上。 所以很多事情，想做就抓紧去做，不要计划更不要拖延，因为你不知道意外会哪天到来，计划也赶不上变化。 趁年轻趁有空，趁学生证还能半价，世界那么大，你该去看看。  别人说的道理是别人的人生，而这个道理不过是告诉你他们的经历，引导你成为更好的人，该怎么做还是在你自己，别人插手不了你的人生。 但愿你活的不后悔，该珍惜的都珍惜。你还年轻，就是最大的资本。 文／丑妹（简书作者）原文链接：http://www.jianshu.com/p/76537e65ce4b ",
            "path": "/2016/04/26/「转」也许，这才是大学真正的意义/"
        },
        {
            "title": "canvas绘制平面花瓣",
            "date": "2016-04-26",
            "content": "   双击鼠标左键添加动态花瓣，(多了动态效果不好)  完整Demo地址Demo  关于 canvas参考资料  HTML5 canvas 标签用于绘制图像（通过脚本，通常是 JavaScript）。  关于 svg参考资料  SVG 意为可缩放矢量图形（Scalable Vector Graphics）。svg图形能够自由的进行缩放，而不会失真，而canvas是位图图像，放大会有像素点。svg通过标签进行操作画图。  演示可以查看我前一段时间做的正则表达式->NFA->DFA->MFA，输入x(a|v*)，查看svg效果  当然，该效果我是用canvas实现的 废话不多说，上菜！解释一下 核心代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function Flower(c,petals,size,x,y,rotate){ this.c = c || [255,255,255]; this.petals = petals || 4; this.size = size || 5; this.x = x || 0; this.y = y || 0; this.rotate = rotate || 0;}Flower.prototype.draw = function(){ var _rad = this.size,_num_pts=this.petals,_x=this.x,_y=this.y,c=this.c; ctx.save(); ctx.shadowBlur = 30; //阴影程度 ctx.lineWidth = 1; ctx.shadowColor = utils.rgba(c[0],c[1],c[2],1); //阴影颜色 ctx.fillStyle = utils.rgba(c[0],c[1],c[2],.6); //填充颜色 c2 = c.map((x)=>Math.floor(x/1.6)); //lambda表达式写法 ctx.strokeStyle = utils.rgba(c2[0],c2[1],c2[2],1); //边框颜色 var pts = []; var _a = this.rotate+(tick*1); for (var i = 0 ; i <= _num_pts ; i++){//增量法提高效率 pts.push({x:utils.P2L(_rad, _a).x,y:utils.P2L(_rad, _a).y}); //P2L将极坐标转换为平面坐标 _a += (360/_num_pts); } for (var i = 1 ; i<= _num_pts; i+=2){ idx= i%_num_pts; ctx.beginPath();//开始绘制 ctx.moveTo(_x,_y);//起点为(_x,_y) ctx.bezierCurveTo(_x+pts[i-1].x,_y+pts[i-1].y,_x+pts[idx+1].x,_y+pts[idx+1].y,_x,_y);//绘制贝塞尔曲线 ctx.stroke();//闭合图形边框 ctx.fill();//填充图形 } ctx.restore();}HTMLCanvasElement.prototype.magicBg = function(){ var ctx = this.getContext('2d'); if(!this.grd){ //实现从画布中心往外呈圆形扩散，渐变。 this.grd=ctx.createRadialGradient(this.width/2,this.height/2,0,this.width/2,this.height/2,Math.min(this.width,this.height)/1.2); this.grd.addColorStop(0,\"rgba(255,255,255,.25)\"); this.grd.addColorStop(1,this.utils.rgba(200+this.utils.randomInt(56),200+this.utils.randomInt(56),200+this.utils.randomInt(56),.65)); } ctx.save(); ctx.clearRect(0,0,this.width,this.height); ctx.fillStyle = this.grd; ctx.fillRect(0,0,this.width,this.height); ctx.restore();}  Flower对象解释      参数 说明 默认 类型     c 花瓣的颜色 [255,255,255] Array   petals 花瓣个数 4 Number   size 半径大小 5 Number   x 中心 x 坐标 0 Number   y 中心 y 坐标 0 Number   rotate 绕中心旋转角度 0 Number(单位：度)     Flower.draw 方法解释     变量 说明     _rad radix，对应size   _num_pts 对应petals   _x 对应x   _y 对应y   c 对应c     关于贝塞尔曲线，参考资料   图：三次贝塞尔曲线动态绘制效果 图：花瓣与其贝塞尔曲线控制点  怎么使用？   <script src='drawflower.js'></script> canvas.drawFlower(option);  123456789101112//default option{ animate:false, rotate:90,  randomSize:true, randomColor:true, randomPetals: true, pos:{ x:this.width/2, y:this.height/2 }} or1234567891011121314{ animate:true, rotate:-20,  randomSize:false, size:10, randomColor:false, color:[100,100,100], randomPetals: false, petals:6, pos:{ x:0, y:0 }} ForkItFork! ",
            "path": "/2016/04/26/canvas绘制平面花瓣/"
        },
        {
            "title": "js实现打字机效果",
            "date": "2016-04-25",
            "content": "  HTMLElement.prototype.findParentByTag = function(tag){ var p = this.parentElement; while(p.tagName!=tag) p = p.parentElement; return p; } HTMLElement.prototype.type = function(op){ op = Object.extend({ delay:25, dest:this, twinkle:'|' },op); var chain = makeChain(this),f=false,html=''; console.log(chain); var dest = op.dest; dest.innerHTML=''; var time = setInterval(function(){ var str = chain.shift(); while(str.length>1){ html+=str; dest.innerHTML=html; str = chain.shift(); if(!chain.length){ clearInterval(time); return; } } html+=str; if(!chain.length){ dest.innerHTML=html clearInterval(time); return; } dest.innerHTML=html+(f?op.twinkle:' '); f=!f; },op.delay); function makeChain(node){ var nodes = node.childNodes; var chain = []; for(var i=0;i < nodes.length;i++){ var ne = nodes[i]; if(ne.nodeType==1){ if(ne.tagName=='SCRIPT'){ chain.push(ne.outerHTML); continue; } var str = ne.cloneNode().outerHTML; var last = str.lastIndexOf('<'); chain.push(str.substring(0,last)); chain = chain.concat(arguments.callee(ne)); chain.push(str.substring(last)); }else if(ne.nodeType==3){ var arr = ne.textContent.match(/(\\s+|[^\\s])/g); if(arr) chain = chain.concat(arr); } } return chain; } } Object.extend = function(){ if(!arguments || !arguments.length) return {}; var rlt = arguments[0]; for(var i=0;i<arguments.length;i++){ var argu = arguments[i]; for(var k in argu) rlt[k] = argu[k]; } return rlt; } function typeHandle(ele){ ele.type({ delay:100, dest:ele, twinkle:'_' }); }  Click Me! Magic   好像挺好玩的哈    项目 价格 数量     计算机 \\$1600 5   手机 \\$12 12   管线 \\$1 234    借鉴了两份代码 jQuery版本 12345678910111213141516171819202122(function (a) { a.fn.typewriter = function () { this.each(function () { var d = a(this), c = d.html(), b = 0; d.show(); d.html(\"\"); var e = setInterval(function () { var f = c.substr(b, 1); if (f == \"<\") { b = c.indexOf(\">\", b) + 1 } else { b++ } d.html(c.substring(0, b) + (b & 1 ? \"_\" : \"\")); if (b >= c.length) { clearInterval(e) } }, 75) }); return this }})(jQuery);  原生JS版本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182function Typing(opts) { this.version = '1.1'; this.source = opts.source; this.output = opts.output; this.delay = opts.delay || 120; this.chain = { parent: null, dom: this.output, val: [] }}Typing.fn = Typing.prototype = { toArray: function(eles) { //Array.prototype.slice; var result = []; for (var i = 0; i < eles.length; i++) { result.push(eles[i]); } return result; }, init: function() { this.chain.val = this.convert(this.source, this.chain.val); }, convert: function(dom, arr) { var that = this, children = this.toArray(dom.childNodes); children.forEach(function(node) { if (node.nodeType === 3) { arr = arr.concat(node.nodeValue.split('')); } else if (node.nodeType === 1) { var val = []; val = that.convert(node, val); arr.push({ 'dom': node, 'val': val }); } }); return arr; }, print: function(dom, val, callback) { setTimeout(function() { dom.appendChild(document.createTextNode(val)); callback(); }, this.delay); }, play: function(ele) { if (!ele) return; if (!ele.val.length && ele.parent) this.play(ele.parent); if (!ele.val.length) return; var curr = ele.val.shift(); var that = this; if (typeof curr === 'string') { this.print(ele.dom, curr, function() { if (ele.val.length) { that.play(ele); } else if (ele.parent) { that.play(ele.parent); } }); } else { var dom = document.createElement(curr.dom.nodeName); var attrs = that.toArray(curr.dom.attributes); attrs.forEach(function(attr) { dom.setAttribute(attr.name, attr.value); }); ele.dom.appendChild(dom); curr.parent = ele; curr.dom = dom; this.play(curr.val.length ? curr : curr.parent); } }, start: function() { this.init(); this.play(this.chain); }}   之我见 第一份jQuery版本，只是对'<','>'两个特殊的字符串进行了判断处理，如果打印那种代码文本时将会有误。 第二份原生JS代码，将元素的孩子结点都进行了处理，这是一种很好的方法，但是，他的数据结构有些复杂化了，有12345{ parent: null, dom: this.output, val: []}   对于那种标签嵌套比较严重和多余的文本结点较多的html处理起来不太美好。 之我改123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263HTMLElement.prototype.type = function(op){ op = Object.extend({ delay:25, dest:this, twinkle:'|' },op); var chain = makeChain(this),f=false,html=''; console.log(chain); var dest = op.dest; dest.innerHTML=''; var time = setInterval(function(){ var str = chain.shift(); while(str.length>1){ html+=str; dest.innerHTML=html; str = chain.shift(); if(!chain.length){  clearInterval(time); return; } } html+=str; if(!chain.length){  dest.innerHTML=html clearInterval(time); return; } dest.innerHTML=html+(f?op.twinkle:' '); f=!f; },op.delay); function makeChain(node){ var nodes = node.childNodes; var chain = []; for(var i=0;i < nodes.length;i++){ var ne = nodes[i]; if(ne.nodeType==1){ if(ne.tagName=='SCRIPT'){ chain.push(ne.outerHTML); continue; } var str = ne.cloneNode().outerHTML; var last = str.lastIndexOf('<'); chain.push(str.substring(0,last)); chain = chain.concat(arguments.callee(ne)); chain.push(str.substring(last)); }else if(ne.nodeType==3){ var arr = ne.textContent.match(/(\\s+|[^\\s])/g); if(arr) chain = chain.concat(arr); } } return chain; }}Object.extend = function(){ if(!arguments || !arguments.length) return {}; var rlt = arguments[0]; for(var i=0;i<arguments.length;i++){ var argu = arguments[i]; for(var k in argu) rlt[k] = argu[k]; } return rlt;} 我吸取了前面两者的优点，比如第一份代码的简单直接，第二份代码的子节点遍历与递归的思路，进一步的解决了前面两者的缺陷。  对无实际意义的文本结点（如 \" 12 \\n sx \" ）进行优化处理，处理为[‘ ‘,’1’,’2’,’ \\n ‘,’s’,’x’,’ ‘]var arr = ne.textContent.match(/(\\s+|[^\\s.])/g); if(arr) chain = chain.concat(arr);  对 script 标签进行优化处理，统一打印文字的节奏if(ne.tagName=='SCRIPT'){ chain.push(ne.outerHTML); continue; }  避免了打印代码块的错误因为代码中分别对 `nodeType == 1` 和 `nodeType == 3` 进行了不同的处理， 可以根据 `chain` 中元素的长度判断是否为文本节点   之我版fork it！ ",
            "path": "/2016/04/25/js实现打字机效果/"
        },
        {
            "title": "js实现的图片瀑布流",
            "date": "2016-04-25",
            "content": " 效果一窥 实现了图片动态加载（滚轮操作）与图片渐现效果（css3动画）  完整Demo点击这里 怎么实现？首先，布局与结构 HTML 123456<ul class='img-wf'><li><div class='img-item'><img src='images/pic-1.jpg' /></div></li><li><div><div class='img-item'><img src='images/pic-2.jpg' /></div></li><li><div class='img-item'><img src='images/pic-3.jpg' /></div></li><li><div class='img-item'><img src='images/pic-4.jpg' /></div></li></ul>  CSS 12345678910111213141516171819202122232425262728293031323334body{background-color:#E9E9E9;}.img-wf{ width:75%; padding:0; margin: auto; list-style:none;}.img-wf li{ position:relative; padding: 3px 1% 3px; float:left; width: 23%;}.img-wf li img{ width:100%;}.img-wf .img-item{ background-color:white; padding: 4px; margin-bottom: 15px;}.img-wf .img-item:hover{ transition: 0.4s; transform:scale(1.05,1.05); box-shadow: 6px 6px 3px gray;}@keyframes fadeIn { 0% {opacity: 0; /*初始状态 透明度为0*/} 100% {opacity: 1; /*结尾状态 透明度为1*/}}.animate{ animation:fadeIn 1.5s;}   可以看到，为了不收屏幕大小影响， width 均设置为 xx%我将 li 设置为 float:left ，也就是说，每一个 li 就占据了一排（因为 width:23%;，一共4排 ），然后通过 js 实现将 <div class='img-item'><img src='images/pic-4.jpg' /></div> 添加至 li 中即可。css中 @keyframes fadeIn，.animate 是css3实现动画，详细请查看 w3c 嗯，然后是js JavaScript1234567891011121314151617181920212223242526272829303132333435363738394041var imgwf = document.querySelector('.img-wf');HTMLElement.prototype.waterfall = function(srcs){ var lis = this.children;  function getRandomImg(onload){ function createImg(src){ var div = document.createElement('div'); div.className = 'img-item'; var img = document.createElement('img'); img.src = src; img.style.display='none'; img.onload = onload; div.appendChild(img); return div; } return createImg(srcs[parseInt(Math.floor(Math.random()*srcs.length))]); } for(var i =0;i<lis.length;i++){ var min = Number.MAX_VALUE; var minLi,t=0; var img = getRandomImg(function(){  this.classList.add('animate'); this.style.display=''; if(min>this.parentElement.parentElement.clientHeight){ min = this.parentElement.parentElement.clientHeight; minLi = this.parentElement.parentElement; } if(++t==lis.length) minLi.appendChild(getRandomImg(function(){this.classList.add('animate');this.style.display='';})); }); lis[i].appendChild(img); }}document.onmousewheel=function(e){ var delta = e.wheelDelta || e.detail; console.log(e); var body = document.body; if(delta<0 && body.scrollTop+body.clientHeight == body.scrollHeight){ imgwf.waterfall(['images/pic-1.jpg','images/pic-2.jpg','images/pic-3.jpg','images/pic-4.jpg']); }}   最后，谈下问题用 float 实现固然简单可行，但是也有不好的地方。li 都设置为浮动元素，那么也就是脱离了文档流，ul 中并没有文档流，所以 ul 的高度为0 其实还有其他的实现方法，比如利用设置 父容器 position:relative, 子元素 position:absolute 然后通过js计算，得到 top,left 值。详细的内容，请点击一篇比较好的文章。 2016/4/30更新！ul高度为0可以通过以下方法解决！1234567ul:after{ content: '.'; display: block; clear: left; height: 0; visibility: hidden;} ",
            "path": "/2016/04/25/js实现的图片瀑布流/"
        },
        {
            "title": "分享一个图标搜索网站(font-awesome)",
            "date": "2016-04-24",
            "content": "  Font-Awesome  ",
            "path": "/2016/04/24/分享一个图标搜索网站(font-awesome)/"
        },
        {
            "title": "b vs strong & i vs em (html标签语义化)",
            "date": "2016-04-24",
            "content": " 关于html标签语义化百度百科用自己的话来说，就是一个是用来给人看的（语义化，如header/footer/nav…）,一个是给机器看的（如一大堆的div，通过css一样可以达到效果）  语义化的网页的好处，最主要的就是对搜索引擎友好，有了良好的结构和语义你的网页内容自然容易被搜索引擎抓取，你网站的推广便可以省下不少的功夫。语义 Web 技术有助于利用基于开放标准的技术，从数据、文档内容或应用代码中分离出意义。   正题关于b/strong & i/em讨论，知乎b和i 是没有感情色彩的，只是一个文本样式而已。strong和em 有感情色彩，strong 加重语气。最重的那种。em 同为加强语气，但气势弱些。那么有无感情色彩有什么作用呢？其实web有个听觉系统，能将页面内容读出来，详细请看CSS听觉参考而 em/strong 在机器识别发音的时候会产生重读效果。 demoI’m strongI’m bI’m emI’m i ",
            "path": "/2016/04/24/b_vs_strong_&_i_vs_em_(html标签语义化)/"
        },
        {
            "title": "捣鼓出一个简陋的图片轮播效果",
            "date": "2016-04-23",
            "content": " 废话不多说，直接看效果 “科学”道理？父元素设置overflow:hidden;,width,height,子div设置position:relative;(还在文档流中)，根据js动态控制其宽度等于所有图片的width总和 container.style.width = document.querySelectorAll('.pic-run>div>img').length*width; 然后，设置图片属性为float:left;，将图片“紧紧”地“挤压”在一排。关于浮动float，我有话要说如下，红色为float:left;，其他均未设置浮动。可以看到其他的div将无视红色。但是，其他div中的文字却被红色挡住了！，所以说  float是用来解决文字环绕图片的问题的！  文字文字 最后根据js修改装载所有图片容器的left值即可。至于动态效果可以参考我的文章 requestAnimationFrame Vs setInterval 附上源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273--- layout: false---<style>.pic-run{ margin: 0 auto; overflow:hidden; width:400px; height:300px;}.pic-run>div{ padding : 0; position:relative; left:-0px;}.pic-run>div>img{ float:left; width:400px; height:300px;}.pic-btn{ clear:both; text-align: center;}</style><script>  function slide(d){ if(slide.time) return; var img = document.querySelector('.pic-run img'); var width = img.width,height = img.height; var show = document.querySelector('.pic-run'); show.style.width = width;show.style.height = height; var container = document.querySelector('.pic-run>div'); var bgleft = parseInt(container.style.left); container.style.width = document.querySelectorAll('.pic-run>div>img').length*width; var delta = -d*width,aimleft = bgleft+delta; if(aimleft<-(parseInt(container.style.width)-width) || aimleft>0) return; if(delta==0) return; function run(){ if(bgleft==aimleft){  cancelAnimationFrame(slide.time); delete slide.time; return; } if(bgleft<aimleft){ bgleft+=50; }else{ bgleft-=50; } container.style.left = bgleft; requestAnimationFrame(run) } slide.time = requestAnimationFrame(run) }</script><div class=\"pic-run\"><div style=\"left:0;\"><img src='images/pic-1.jpg' /><img src='images/pic-2.jpg' /><img src='images/pic-3.jpg' /><img src='images/pic-4.jpg' /></div></div><div class='pic-btn'><button onclick='slide(-1)'>Prev</button><button onclick='slide(1)'>Next</button></div><script> window.onload = function(){slide(0);};</script> ",
            "path": "/2016/04/23/捣鼓出一个简陋的图片轮播效果/"
        },
        {
            "title": "requestanimationframe vs setinterval",
            "date": "2016-04-23",
            "content": " 介绍大家对setInterval一定不陌生，但可能不太了解requestAnimationFramerequestAnimationFrame是HTML5新添的api，两者都能产生动画效果。 区别requestAnimationFrame 参数只有一个参数，是用来循环调用的方法，setInterval 有两个参数，第一个是方法，第二个是循环调用的时间。但是，JavaScript是单线程的，也就是同一时间只能有一句JavaScript语句执行所以，setInterval的实现是通过事件驱动完成的，当时间到了之后，setInterval加入事件队列，等待JavaScript的青睐，所以这种计时是不准确的。 Demofunction progress(p){p.style.width='0%';p.innerText='0%';function run(){var w = parseInt(p.style.width);p.innerText = w +'%';if(w==100) return;p.style.width = w+1+'%';setTimeout(arguments.callee,15)}setTimeout(run,15);} 0 RUN progress(document.querySelector('#progress')); 123456789101112function progress(p){ p.style.width='0%'; p.innerText='0%'; function run(){ var w = parseInt(p.style.width); p.innerText = w +'%'; if(w==100) return; p.style.width = w+1+'%'; requestAnimationFrame(arguments.callee) } requestAnimationFrame(run);} function progress2(p){p.style.width='0%';p.innerText='0%';function run(){var w = parseInt(p.style.width);p.innerText = w +'%';if(w==100){clearInterval(t); return;}p.style.width = w+1+'%';}var t =setInterval(run,15);} 0 RUN progress2(document.querySelector('#progress2')); 12345678910111213function progress2(p){ p.style.width='0%'; p.innerText='0%'; function run(){ var w = parseInt(p.style.width); p.innerText = w +'%'; if(w==100){ clearInterval(t); return; } p.style.width = w+1+'%'; } var t =setInterval(run,15);}  可以看到，requestAnimationFrame代码量更少。 惊天秘密 深入理解，可以把requestAnimationFrame(func)等效为setTimeout(func,15); 不信，你试下嘛。 当然，requestAnimationFrame在浏览器查看其它网页的一段时间后，便会自动停止动画。 在threejs中，就是用requestAnimationFrame来减少cpu负载的。 2016/5/15 更新 requestAnimationFrame 中会默认传入一个相对的时间戳，详细看这里； setTimeout(func,15);除了这种用法以外，还可以setTimeout(func,15,args);传入参数，当然setInterval也一样。 ",
            "path": "/2016/04/23/requestAnimationFrame_Vs_setInterval/"
        },
        {
            "title": "短暂的git捣鼓",
            "date": "2016-04-23",
            "content": " Git是个啥？ Git 并不像 SVN 那样有个中心服务器。目前我们使用到的 Git 命令都是在本地执行，如果你想通过 Git 分享你的代码或者与其他开发人员合作。 你就需要将数据放到一台其他开发人员能够连接的服务器上。  这是网上的话，我也就是看看而已，谈谈我自己的认识吧。我觉得，git是一个在本地管理代码版本的东东，有分支，仓库等概念，而github是基于git的一个远程仓库，通过他能实现代码分享。不通过它也可以进行版本控制  我想做什么？我想把我博客的文章啊，主题啊，配置啊放到GitHub上，以免以后电脑报销后，写的博文也有个备份。 那要怎么做？把本地的Git和GitHub联系起来 本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以我们需要配置验证信息   使用下面指令生成SSH Key  ssh-keygen -t rsa -C \"youremail@example.com\"  成功后，会给你一个ssh key路径，找到对应的ssh key文件(后缀*.pub)  来到 GitHub 个人首页，在设置中，添加一个SSH Key。title 可以随便取名字，Key 里面添加的内容为 id_rsa.pub 文件内所有的代码。然后点击 Apply 即可。  测试与 GitHub 是否连接成功：SSH -v git@github.com 这里我遇到了问题在前面的文章感受Hexo的强大与高效（搭建Blog至GitHub Page教程）中，我提到了需要为你的username.github.io项目添加SSH Key，其实吧，这一步可以忽略，直接生成一个访问你github的ssh key即可。不然你再次添加ssh key时候，因为本地的ssh key文件已经被你的项目使用了，所以会出现错误。 连接成功后，在GitHub中新建一个repository  在git bash中不断的../,cd后，来到我的blog文件夹。 执行下列指令 1234567git init # 添加本地git仓库，在文件夹中出现`.git`文件夹git remote add origin git@github.com:cong25825933/blogsource.git # 添加远程github服务器git add source # 将博文内容加入缓存 git add 命令来添加当前项目的所有文件。git add themesgit add _config.yml # 我只需要备份这三份文件git commit -m 'first commit' # 将缓存区内容添加到仓库中。git push -u origin master # 发送至Github  如果没什么大乱子的话，应该就成功了。 没啦  ",
            "path": "/2016/04/23/短暂的git捣鼓/"
        },
        {
            "title": "看我blog文章导航会动哎！",
            "date": "2016-04-22",
            "content": "  实现侧边内容的动态跳转，非锚点。点击右侧的文章侧边导航栏，实现动态效果跳转。  怎么实现滴？ 找到hexo文件夹中你选择的主题文件夹，在我这是themes/indigo 进入source/js，修改js文件 1234567891011121314151617181920212223242526272829303132333435363738394041/* * d->document; * animate->requestAnimationFrame */var links = d.querySelectorAll('.post-toc-link');for(var i = 0;i < links.length;i++){ var link = links.item(i); link.addEventListener('click',function(e){ e.preventDefault(); var id = this.hash; var tg = d.querySelector(id); var max = d.body.scrollHeight - d.body.offsetHeight,tg_parent_top = tg.offsetParent.offsetTop; function scrollToLink(){ var to = tg.offsetTop+tg_parent_top - 40, top = d.body.scrollTop; if(top > to){ top -= 130; if(top < to){ d.body.scrollTop = to; return; } d.body.scrollTop = top; animate(arguments.callee); } else if(top < to){ if(top==max){ d.body.scrollTop = to; return; } top += 130; if(top > to){ d.body.scrollTop = to; return; } d.body.scrollTop = top; animate(arguments.callee); }  } animate(scrollToLink); })}; 经过这个小Demo，我发现一个小知识点  元素的offsetTop对相对于其设置了position属性的祖宗元素（若无则为body）。  不信？！请看下面的测试 我是第一！ 第一的内容！ position:relative; height:700px;  function alertAttr(obj,attr){alert(obj[attr]);} 点击看我的offsetTop   我是第二！ 第二的内容！ height:800px; 点击看我的offsetTop 我是第三！ 第三的内容！ height:500px;   更多的细节还可以看元素的offsetParent属性  ",
            "path": "/2016/04/22/看我Blog文章导航会动哎！/"
        },
        {
            "title": "一次百度前端实习生面试",
            "date": "2016-04-22",
            "content": "  昨天下午3点至下午4点，进行了百度内推的前端实习生视频面试（当然得先过一轮笔试测试）  开始视频开启用的是微软的Skype远程视频，一开始我还以为我能看到面试官的尊容的，没想到面试官太“羞涩”。 自我介绍真的是不太擅长自我介绍，说了下自己来自哪里，基本的情况，然后提了下我的项目，就不知道说什么了，导致面试官还有点不适应。 问题主观问题 你怎么学前端的啊？在做项目的过程中，边做边学，查资料看视频看书。  你为什么选择前端？js既灵活（闭包，函数对象等），又简单（单线程）；通过浏览器实现跨平台； js还可以做服务器，游戏，桌面应用，webapp...  你觉得前端必须要掌握的知识基本的HTML标签用法，常用的css重难点，js一定需要精通。  你会自己写技术博客吗看到比较好的文章会收藏或者转载，自己一般都是写的项目总结报告，关于技术细节方面的写的比较少。  你有哪些前端学习的书籍...只有一本《JavaScript高级程序设计》   客观问题 谈谈web标准 谈谈HTML5语义化（面试官会挖坑） 谈谈行内元素，块元素，img是块元素吗 怎么改变元素的类型（行内，块元素） 谈谈浮动，清除浮动 谈谈css定位 谈谈JavaScript作用域、闭包、对象与原型链 谈谈js面向对象 谈谈js基本数据类型 数组的克隆，jQuery中怎么实现克隆(这个不太明白面试官考查的点，我觉得可以自己实现个数组复制的函数) 说下快排的思想（唯一的一个算法题目） 谈下事件委托 谈下vui/yui/angularjs/reactjs这些主流的前端框架（…因为没用过，所以…） 谈下浏览器兼容性方面 谈下Yahoo提出的web性能优化标准 你有什么对jQuery源码的深刻理解认识吗（(⊙﹏⊙)b，没有）  提问 面试官你觉得我有什么需要提高的地方？需要多写些技术博客，需要多接触主流的前端框架。   总结与计划总结 面试官提的问题与面经上的题目大都一致，这些可以通过临时抱佛脚拾取；但是对于那些需要长时间积累的（比如技术博客，主流框架的学习），只能脚踏实地地积累了。多经历还是有好处的，至少知道了自己与大公司需要的人才有哪些需要提高的地方。还有，一面面试官居然没怎么问我的在线考试交友网站，可能他不太感兴趣吧。  计划 搭建我的个人博客（做起来也更有动力成就感，说完我便搭建了这个网站） 学习angularjs/seajs，减少对jQuery的依赖 得开始准备期中考试了…，准备面试已经一个礼拜没上课了…  Fighting！ ",
            "path": "/2016/04/22/一次百度前端实习生面试/"
        },
        {
            "title": "markdown语法测试demo",
            "date": "2016-04-22",
            "content": " 一级标题# 一级标题(前后含空格) 二级标题## 二级标题 …以此类推 粗体字 **粗体字** 斜体字 *斜体字* 粗斜体字 ***粗斜体字***  引用块  > 引用块 水平分割线  ------ 超链接[超链接](http://baidu.com) 行内代码 行代码块 12345/* * 高亮代码块 */ var moyu = 'A Boy'; window.moyu = '';  无序列表项 一 无序列表项 二 无序列表项 三  123- 无序列表项 一- 无序列表项 二- 无序列表项 三  有序列表项 一 有序列表项 二 有序列表项 三  1231. 有序列表项 一2. 有序列表项 二3. 有序列表项 三 1![图片](/images/img.jpg)    项目 价格 数量     计算机 \\$1600 5   手机 \\$12 12   管线 \\$1 234    123456789101112131415161718192021222324252627282930313233343536<table> <thead> <tr> <th>Head1</th> <th>Head2</th> <th>Head3</th> <th>Head4</th> </tr> </thead> <tbody> <tr> <td>John</td> <td>Smith</td> <td>123 Main St.</td> <td>Springfield</td> </tr> <tr> <td>Mary</td> <td>Jones</td> <td>456 Pine St.</td> <td>Dover</td> </tr> <tr> <td>Jim</td> <td>Baker</td> <td>789 Park Ave.</td> <td>Lincoln</td> </tr> </tbody></table>| 项目 | 价格 | 数量 || -------- | -----: | :----: || 计算机 | \\$1600 | 5 || 手机 | \\$12 | 12 || 管线 | \\$1 | 234 | 参考 Cmd Markdown 高阶语法手册 了解更多高级功能。 ",
            "path": "/2016/04/22/MarkDown语法测试Demo/"
        },
        {
            "title": "感受hexo的强大与高效（搭建blog至github page教程）",
            "date": "2016-04-22",
            "content": " Hexo 是一个基于NodeJs平台实现的一个快速生成自己Blog的程序，据说作者是一位来自台湾的大学生，666.Hexo官方网站 首先，安装Hexo先得有NodejsNodejs官网  安装Hexo 全局安装Hexonpm install -g hexo 创建你的Blog/Hexo文件夹hexo init blog 进入blog文件夹cd blog 安装Hexo依赖包，根据blog文件夹中的package.json配置下载npm install 运行服务器（默认地址为 localhost:4000）hexo server注意：这里不需要运行 hexo g 指令，所以我们访问的页面是根据nodejs动态生成的。 选择你喜欢的Hexo ThemeHexo主题选择鄙人选择的是这位仁兄的 https://github.com/yscoder上面有相关的配置的说明。创建你的github.io项目  新建repository新建一个以{username}.github.io 命名的repository。 得到你的SSH地址在blog文件夹中的_config.yml文件中配置1234deploy: type: git repo: {ssh地址} branch: 在GitHub中设置中创建你的page添加ssh key （允许写操作） 在Git Bash输入以下指令（任意位置点击鼠标右键），检查是否已经存在了SSH keys。ls -al ~/.ssh 如果不存在就没有关系，如果存在的话，直接删除c:/用户/你的用户名/.ssh文件夹里面所有文件 输入以下指令（邮箱就是你注册Github时候的邮箱）后，回车ssh-keygen -t rsa -C \"your email\" 然后它会提示要你输入passphrase（如上图，我没有输入直接回车，如果你输入的话，要记得，到时候会用到）。 然后键入以下指令：eval 'ssh-agent -s'ssh-add 继续输入指令：ssh-add ~/.ssh/id_rsa 到了这一步，就可以添加SSH key到你的Github账户了。键入以下指令，拷贝Key（先拷贝了，等一下可以直接粘贴）：clip < ~/.ssh/id_rsa.pub 在GitHub设置添加ssh keys，将上面复制的内容粘贴至key中，生成  输入你的Github密码即可完成SSH Key的添加。嗯，最后还是测试一下吧，键入以下命令：ssh -T git@github.com #你可能会看到有警告，没事，输入“yes”就好。 发布至GitHub并且部署 输入指令hexo g #生成blog静态文件，github page只支持静态文件 输入指令hexo d #发布至github中 完成！快去访问你的page吧！  ",
            "path": "/2016/04/22/感受Hexo的强大与高效（搭建Blog至GitHub Page教程）/"
        }
    ],
    "dateMap": {
        "2016-07-25": [
            0
        ],
        "2016-07-01": [
            1
        ],
        "2016-06-20": [
            2
        ],
        "2016-06-10": [
            3
        ],
        "2016-06-06": [
            4
        ],
        "2016-06-03": [
            5,
            6,
            7
        ],
        "2016-06-02": [
            8
        ],
        "2016-05-30": [
            9,
            10
        ],
        "2016-05-28": [
            11
        ],
        "2016-05-25": [
            12
        ],
        "2016-05-22": [
            13
        ],
        "2016-05-10": [
            14
        ],
        "2016-05-04": [
            15
        ],
        "2016-05-02": [
            16
        ],
        "2016-05-01": [
            17
        ],
        "2016-04-30": [
            18,
            19
        ],
        "2016-04-29": [
            20
        ],
        "2016-04-28": [
            21
        ],
        "2016-04-27": [
            22
        ],
        "2016-04-26": [
            23,
            24
        ],
        "2016-04-25": [
            25,
            26
        ],
        "2016-04-24": [
            27,
            28
        ],
        "2016-04-23": [
            29,
            30,
            31
        ],
        "2016-04-22": [
            32,
            33,
            34,
            35
        ]
    },
    "titleMap": {
        "数字验证码识别": [
            0
        ],
        "「滴滴滴，老司机开车了」nodejs爬取煎蛋网妹子图": [
            1
        ],
        "图书销售系统（书窝）": [
            2
        ],
        "「项目拾遗」http文件浏览（静态文件+express4.x+md/code文件渲染）": [
            3
        ],
        "「思科模拟器」建立dns+http服务": [
            4
        ],
        "「项目拾遗」简单图形处理及图形绘制": [
            5
        ],
        "「图像处理」图像的复原": [
            6
        ],
        "「图像处理」图像的直方图均衡化": [
            7
        ],
        "「思科模拟器」构建虚拟局域网（vlan）": [
            8
        ],
        "「node网络编程」smtp客户端程序": [
            9
        ],
        "「node网络编程」ftp客户端程序": [
            10
        ],
        "node+express+jade实现http文件浏览器": [
            11
        ],
        "解决外网访问nodejs服务器（nginx反向代理）": [
            12
        ],
        "基于socket.io实现的简易你画我猜": [
            13
        ],
        "「项目拾遗」几个计算机图形学的前端程序": [
            14
        ],
        "百度前端二面总结（已过）": [
            15
        ],
        "「转」为什么v8 javascript引擎这么快": [
            16
        ],
        "「ecmascript6」promise介绍与nodejs实践运用(q.js)": [
            17
        ],
        "「项目拾遗」谈谈websocket": [
            18
        ],
        "谈谈javascript之数组对象深拷贝": [
            19
        ],
        "从定时器到 web worker": [
            20
        ],
        "git捣鼓记之「pull request」": [
            21
        ],
        "play css3 animation": [
            22
        ],
        "「转」也许，这才是大学真正的意义": [
            23
        ],
        "canvas绘制平面花瓣": [
            24
        ],
        "js实现打字机效果": [
            25
        ],
        "js实现的图片瀑布流": [
            26
        ],
        "分享一个图标搜索网站(font-awesome)": [
            27
        ],
        "b vs strong & i vs em (html标签语义化)": [
            28
        ],
        "捣鼓出一个简陋的图片轮播效果": [
            29
        ],
        "requestanimationframe vs setinterval": [
            30
        ],
        "短暂的git捣鼓": [
            31
        ],
        "看我blog文章导航会动哎！": [
            32
        ],
        "一次百度前端实习生面试": [
            33
        ],
        "markdown语法测试demo": [
            34
        ],
        "感受hexo的强大与高效（搭建blog至github page教程）": [
            35
        ]
    }
}